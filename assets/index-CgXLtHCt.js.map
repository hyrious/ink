{"version":3,"file":"index-CgXLtHCt.js","sources":["../../src/base.ts","../../src/spring.ts","../../src/stroke.ts","../../main.ts"],"sourcesContent":["export const clamp = (value: number, min: number, max: number) => value < min ? min : value > max ? max : value;\n\nexport interface IPoint {\n  readonly x: number;\n  readonly y: number;\n}\n\nexport interface IRectangle extends IPoint {\n  readonly width: number;\n  readonly height: number;\n}\n\nexport class Vec {\n  /// @internal\n  constructor(\n    readonly x: number,\n    readonly y: number,\n  ) { }\n\n  static of(x: number, y: number) {\n    return new Vec(x, y);\n  }\n\n  static from(vec: IPoint) {\n    return new Vec(vec.x, vec.y);\n  }\n\n  add(other: IPoint) {\n    return new Vec(this.x + other.x, this.y + other.y);\n  }\n\n  subtract(other: IPoint) {\n    return new Vec(this.x - other.x, this.y - other.y);\n  }\n\n  multiply(scalar: number) {\n    return new Vec(this.x * scalar, this.y * scalar);\n  }\n\n  normalize(d = Math.hypot(this.x, this.y)) {\n    return new Vec(this.x / d, this.y / d);\n  }\n\n  /// Rotate the vector by 90 degrees. → becomes ↑\n  permutate() {\n    return new Vec(-this.y, this.x);\n  }\n\n  negative() {\n    return new Vec(-this.x, -this.y);\n  }\n\n  middle(other: IPoint) {\n    return new Vec((this.x + other.x) / 2, (this.y + other.y) / 2);\n  }\n\n  /// Rotate the vector around a center point.\n  rotate(center: IPoint, radius: number) {\n    const s = Math.sin(radius), c = Math.cos(radius),\n          px = this.x - center.x, py = this.y - center.y,\n          nx = px * c - py * s, ny = px * s + py * c;\n    return new Vec(nx + center.x, ny + center.y);\n  }\n\n  dot(other: IPoint) {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  lerp(other: IPoint, t: number) {\n    return new Vec(this.x + (other.x - this.x) * t, this.y + (other.y - this.y) * t);\n  }\n\n  project(other: IPoint, c: number) {\n    return new Vec(this.x + other.x * c, this.y + other.y * c);\n  }\n}\n","const enum C {\n  timespan = 0.016667,\n  stiffness = 0.7,\n  damping = 0.5,\n  precision = 0.01,\n}\n\nexport class Spring {\n  value = -1\n  last = -1\n  target = -1\n  set(target: number): this {\n    this.target = target\n    if (this.value < 0) {\n      this.value = target\n      this.last = target\n    }\n    return this\n  }\n  update(dt?: number): number {\n    if (!dt) dt = C.timespan\n    if (this.value >= 0 && this.target >= 0 && this.last >= 0) {\n      let v = this.target\n      let delta = v - this.value\n      let velocity = (this.value - this.last) / dt\n      let spring = C.stiffness * delta\n      let damper = C.damping * velocity\n      let acceleration = spring - damper\n      let d = (velocity + acceleration) * dt\n      this.last = this.value\n      if (Math.abs(d) < C.precision && Math.abs(delta) < C.precision) {\n        this.value = this.target\n      } else {\n        this.value += d\n      }\n    }\n    return this.value\n  }\n}\n","//\n// Strokes are made up of a series of points, each point may have a pressure and a timestamp.\n// The algorithm's goal is to calculate a smooth outline of these points with known information.\n// The basic idea is each stroke is affected by 2 factors:\n//\n// - \"Thinning\": The stroke will be thinner if the pressure is lower and\n//               distance per interval between points become longer.\n//               Without timestamp we can assume the interval is constant.\n//\n// - \"Spreading\": The last several points will spread (be bigger) even after you lift the pen.\n//\n\nimport { clamp, IPoint, Vec } from \"./base\";\nimport { Spring } from \"./spring\";\n\n/// The data structure for raw input point, should be easy to convert from pointer events.\nexport class RawPoint implements IPoint {\n  /// @internal\n  constructor(\n    readonly x: number,\n    readonly y: number,\n    /// Pressure, range from 0 to 1. Use 0.5 for no-pressure cases.\n    readonly p: number,\n    /// Timestamp in milliseconds. Use 0 for no-timestamp cases.\n    readonly t: number,\n  ) { }\n\n  /// Construct a RawPoint from x, y, pressure and timestamp.\n  static of(x: number, y: number, pressure: number, timestamp: number) {\n    return new RawPoint(x, y, pressure, timestamp);\n  }\n\n  /// Construct a RawPoint from a PointerEvent.\n  /// The position is from clientX and clientY, which may not be the best choice\n  /// for draw boards supporting pinch and zoom. Use {@link RawPoint.of} instead.\n  static fromEvent(event: PointerEvent, pressure = clamp(event.pressure || 0.5, 0, 1)) {\n    // Some stylus devices may report zero pressure, treat as no-pressure.\n    return new RawPoint(event.clientX, event.clientY, pressure, event.timeStamp);\n  }\n\n  /// @internal\n  static fromJSON(json: any) {\n    return new RawPoint(json.x, json.y, json.p, json.t);\n  }\n}\n\n/// The data structure for a point in a stroke, it has context information like\n/// its direction, distance to the previous point, and running length.\nexport class Point {\n  /// @internal\n  constructor(\n    readonly p: RawPoint,\n    /// Inverted direction of this point, equals to `previous - current`.\n    /// The first point's direction is the same as the second point.\n    readonly v: Vec,\n    /// Distance to the previous point, equals to `hypot(previous - current)`.\n    readonly d: number,\n    /// Running length from the first point to this point.\n    readonly l: number,\n  ) { }\n\n  static of(point: RawPoint, vector: Vec, distance: number, length: number) {\n    return new Point(point, vector, distance, length);\n  }\n\n  /// @internal\n  static fromJSON(json: any) {\n    return new Point(RawPoint.fromJSON(json.p), Vec.from(json.v), json.d, json.l);\n  }\n}\n\n// Constants which should not be exported as options.\nconst enum C {\n  // Skip points that are too close.\n  SkipDistance = 4,\n  // If the last |segment| > `TailDistance * size`, draw a thinner tail,\n  // otherwise draw an end cap.\n  TailDistance = 0.4,\n  // Math.PI + 0.0001 to prevent floating number issue when drawing the cap.\n  PI = 3.1416926535897933,\n  // Simulate pressure for mouse and trackpad.\n  PressureChangeSpeed = 0.7,\n  // Approximate ratio that multiplies `size` to draw a dot.\n  DotSize = 0.36,\n  // Minimal stroke width / 2.\n  MinRadius = 0.75,\n  // Spreading interval in milliseconds.\n  SpreadInterval = 300,\n  // Spreading amount per interval.\n  SpreadAmount = 0.12,\n}\n\n/// @internal Increase each point's pressure in the next period with a small amount.\nfunction pressureTillNow(p: Point, now: number) {\n  if (now - p.p.t > C.SpreadInterval) return Math.min(p.p.p + C.SpreadAmount, 1);\n  return Math.min(p.p.p + C.SpreadAmount * (now - p.p.t) / C.SpreadInterval, 1);\n}\n\n/// @internal Increase pressure for the next period with a small amount.\nfunction pressureTillNow2(p: number, t: number, now: number) {\n  if (now - t > C.SpreadInterval) return Math.min(p + C.SpreadAmount, 1);\n  return Math.min(p + C.SpreadAmount * (now - t) / C.SpreadInterval, 1);\n}\n\n/// The data structure for a stroke.\nexport class Stroke {\n  /// Indexes to split {@link Stroke.points} into curves. The first index is always `0`.\n  readonly segments: number[] = [0]\n  /// @internal See {@link Stroke.insert}.\n  readonly pending: { [from: number]: RawPoint[] } = { __proto__: null } as any\n\n  /// @internal\n  constructor(\n    /// The stroke's points. It grows on {@link Stroke.insert} and {@link Stroke.push}.\n    readonly points: Point[],\n    /// The stroke's length, equals to `points.at(-1).l`.\n    /// {@link Stroke.insert} and {@link Stroke.push} will update this value.\n    readonly length = points.length > 0 ? points[points.length - 1].l : 0,\n  ) { }\n\n  /// Create a stroke from raw points.\n  static of(raw: RawPoint[] = []): Stroke {\n    let stroke = new Stroke([], 0)\n    for (let p of raw) stroke._push(p)\n    stroke._updateSegments()\n    return stroke\n  }\n\n  /// Revive a stroke from `JSON.parse(JSON.stringify(oldStroke))`.\n  static fromJSON(json: any) {\n    let stroke = new Stroke(json.points.map(Point.fromJSON), json.length);\n    (stroke as { segments: number[] }).segments = json.segments;\n    (stroke as { pending: { [from: number]: RawPoint[] } }).pending = json.pending;\n    return stroke;\n  }\n\n  /// True when no points in the stroke.\n  get empty() { return this.length == 0 }\n\n  /// True when the stroke has only one point.\n  get dot() { return this.points.length == 1 }\n\n  /// Update the stroke with new points inserted from `from`.\n  /// The `from` can exceed the stroke's length, where the points will be\n  // pending until there be new points fill the gap.\n  insert(from: number, raw: RawPoint[]): this {\n    if (from == this.points.length) {\n      for (let p of raw) this._push(p)\n      from = this.points.length\n      if (raw = this.pending[from]) {\n        delete this.pending[from]\n        this.insert(from, raw)\n      }\n      // Recursively call {@link Stroke.insert} to flush pending points.\n      // Ensure a {@link Stroke._updateSegments} is called at the end of the recursion.\n      else {\n        this._updateSegments()\n      }\n    }\n    else if (from > this.points.length) {\n      this.pending[from] = raw\n    }\n    else {\n      throw new RangeError(`Position ${from} conflicts with existing points`)\n    }\n    return this\n  }\n\n  /// Update the stroke by pushing new points to the end.\n  push(raw: RawPoint): this {\n    this._push(raw)\n    this._updateSegments()\n    return this\n  }\n\n  /// @internal This method does not call `_updateSegments`.\n  _push(raw: RawPoint) {\n    let points = this.points\n    if (points.length > 0) {\n      let prev = points[points.length - 1]\n      let d = Math.hypot(raw.x - prev.p.x, raw.y - prev.p.y)\n      this._updateLength(d)\n      if (this.length - prev.l < C.SkipDistance) {\n        // Skip this point, but preserve its pressure.\n        (prev.p as { p: number }).p = Math.max(prev.p.p, raw.p)\n        return\n      }\n      points.push(Point.of(raw, Vec.from(raw).subtract(prev.p).normalize(), d, this.length))\n    } else {\n      points.push(Point.of(raw, Vec.of(0, 0), 0, 0))\n    }\n  }\n\n  /// Is the stroke still \"spreading\"?\n  isSpreading(now = performance.now()): boolean {\n    return this.points.length > 0 && now - this.points[this.points.length - 1].p.t < C.SpreadInterval\n  }\n\n  /// Compute the outline points of the segment starting at `from`.\n  /// Returns an empty array if `from` is not in {@link Stroke.segments}.\n  /// The `size` is the full width when pressure is 1.\n  outline(from: number, size: number, now = performance.now()): IPoint[] {\n    let end = this.segments.find(end => from < end)\n    let points = this.points.slice(from > 0 ? from - 1 : from, end)\n    if (points.length > 1) {\n      let leftPoints: Vec[] = [], rightPoints: Vec[] = [], length = points.length,\n          radius = size, prevPressure = points[0].p.p, drawEndCap = true,\n          prevTimestamp = 0, spring = new Spring()\n      // Draw a tail if the last segment is long enough.\n      if (end == null && length >= 2) {\n        let p2 = points[length - 2]\n        // The precisely comparing to 0.5 and 1.0 is probably a mouse event generated by chrome or firefox.\n        if ((p2.p.p == 0.5 || p2.p.p == 1) && p2.d > C.TailDistance * size) {\n          drawEndCap = false\n        }\n      }\n      // Simulate pressure and push points.\n      for (let i = 0; i < length; i++) {\n        let { p, v, d } = points[i]\n        // Fix first point's distance and direction (assume the same as the next point).\n        if (i == 0) {\n          d = 0\n          v = points[1].v\n        }\n        let sp = Math.min(1, d / size), rp = Math.min(1, 1 - sp),\n            pressure = Math.min(1, prevPressure + (rp - prevPressure) * (sp * C.PressureChangeSpeed)),\n            nextVector = (i < length - 1 ? points[i + 1] : points[i]).v,\n            nextDot = i < length - 1 ? v.dot(nextVector) : 1\n\n        pressure = spring.set(pressure).update(prevTimestamp && (p.t - prevTimestamp) / 1000)\n        // Tail case.\n        if (!drawEndCap) {\n          if (i == length - 1) pressure = 0.05\n          if (i == length - 2) pressure = Math.max(0.1, pressure - 0.2)\n          if (i == length - 3) pressure = Math.max(0.1, pressure - 0.1)\n        }\n\n        radius = clamp(size * 0.5 * pressureTillNow2(pressure, p.t, now), C.MinRadius, size / 2)\n\n        let offset = nextVector.lerp(v, nextDot).permutate().multiply(radius),\n            pl = Vec.from(p).subtract(offset),\n            pr = Vec.from(p).add(offset)\n\n        leftPoints.push(pl)\n        rightPoints.push(pr)\n\n        prevTimestamp = p.t\n        prevPressure = p.p\n      }\n      let startCap: Vec[] = [], firstPoint = rightPoints[0], endCap: Vec[] = []\n      for (let step = 1 / 13, t = 0; t <= 1; t += step) {\n        startCap.push(firstPoint.rotate(points[0].p, C.PI * t))\n      }\n      if (drawEndCap) {\n        let lastPoint = points[length - 1],\n            direction = lastPoint.v.negative().permutate(),\n            start = Vec.from(lastPoint.p).project(direction, radius)\n        for (let step = 1 / 13, t = 0; t < 1; t += step) {\n          endCap.push(start.rotate(lastPoint.p, C.PI * t))\n        }\n      }\n      return leftPoints.concat(endCap, rightPoints.reverse(), startCap)\n    }\n    // Dot case.\n    else if (points.length == 1) {\n      let p = points[0],\n          start = Vec.from(p.p).project(Vec.of(1, 0), size * C.DotSize * pressureTillNow(p, now)),\n          circle: Vec[] = []\n      for (let step = 1 / 13, t = 0; t <= 2; t += step) {\n        circle.push(start.rotate(p.p, C.PI * t))\n      }\n      return circle\n    }\n    else {\n      return []\n    }\n  }\n\n  /// Construct an SVG path string from raw points with basic smoothing.\n  stroke(points: IPoint[] = this.points.map(p => p.p)): string {\n    let n = points.length\n    if (n == 0) return \"\"\n    let prev = points[0], path = `M${prev.x.toFixed(2)},${prev.y.toFixed(2)}`\n    for (let i = 1; i < n; i++) {\n      let curr = points[i], middle = Vec.from(prev).middle(curr)\n      if (i == 1) path += `L${middle.x.toFixed(2)},${middle.y.toFixed(2)}`\n      else path += `Q${prev.x.toFixed(2)},${prev.y.toFixed(2)} ${middle.x.toFixed(2)},${middle.y.toFixed(2)}`\n      prev = curr\n    }\n    if (n > 1) path += `L${prev.x.toFixed(2)},${prev.y.toFixed(2)}`\n    return path\n  }\n\n  /// @internal Increase the running length.\n  _updateLength(d: number) {\n    (this as { length: number }).length += d\n  }\n\n  /// @internal Update {@link Stroke.segments} using current {@link Stroke.points}.\n  _updateSegments() {\n    let segments = this.segments, points = this.points, n = points.length\n    for (let i = segments[segments.length - 1] + 1; i < n; i++) {\n      if (points[i].v.dot(points[i - 1].v) < 0) {\n        segments.push(i)\n        i++\n      }\n    }\n  }\n}\n","import { clamp, RawPoint, Stroke } from './src/ink'\n\nlet $root = document.getElementById('app')!\nlet $svg = $root.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'svg'))\nlet $mask = $root.appendChild(document.createElement('div'))\nlet $settings = {\n  color: document.getElementById('stroke-color') as HTMLInputElement,\n  size: document.getElementById('stroke-size') as HTMLInputElement,\n  clear: document.getElementById('clear') as HTMLButtonElement,\n  undo: document.getElementById('undo') as HTMLButtonElement,\n  redo: document.getElementById('redo') as HTMLButtonElement,\n  pressure: document.getElementById('pressure') as HTMLInputElement,\n  eraser: document.getElementById('eraser') as HTMLInputElement,\n}\n\n$svg.setAttribute('fill-rule', 'nonzero')\n$svg.setAttribute('fill', 'currentColor')\n$svg.style.cssText = `display: block; width: 100%; height: 100%;\nfont-size: 0; touch-action: none; position: relative; contain: content;\noverflow: hidden; overscroll-behavior: none;`\n\n$mask.style.cssText = `display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;\ntouch-action: none; contain: content; z-index: 1;`\n\n$settings.color.value = matchMedia('(prefers-color-scheme: dark)').matches ? '#ffffff' : '#000000'\n\n$settings.clear.onclick = () => {\n  let current = Array.from($svg.children)\n  $svg.textContent = ''\n  undoStack.commit(\n    () => $svg.append(...current),\n    () => $svg.textContent = '',\n  )\n}\n\n$settings.undo.onclick = () => undoStack.undo()\n$settings.redo.onclick = () => undoStack.redo()\n\nlet pressure: 0.5 | undefined\n\n$settings.pressure.oninput = () => {\n  pressure = $settings.pressure.checked ? void 0 : 0.5\n}\n\n$settings.eraser.oninput = () => {\n  let erasing = $settings.eraser.checked\n  $svg.style.cursor = erasing ? `url(https://api.iconify.design/mdi:eraser.svg?color=${encodeURIComponent($settings.color.value)}) 0 32, auto` : 'default'\n  $mask.style.display = erasing ? 'block' : 'none'\n}\n\nlet running = new Map<number, PointerEvent>()\n\n$svg.onpointerdown = (e) => {\n  let id = e.pointerId\n  if (running.has(id)) onCancel(id)\n  running.set(id, e)\n  e.preventDefault()\n  e.stopPropagation()\n  $svg.setPointerCapture(id)\n  // Ideally it should save $svg.getBoundingClientRect() for calculating the offset.\n  // In our demo case the offset is always 0.\n  onOpen(id, RawPoint.fromEvent(e, pressure))\n}\n\n$svg.onpointermove = (e) => {\n  let id = e.pointerId\n  e.preventDefault()\n  e.stopPropagation()\n  if (running.has(id)) {\n    let e0 = running.get(id)!\n    // Apple pencil's bug, it fires 2 identical events.\n    if (e0.clientX === e.clientX && e0.clientY === e.clientY) return\n    running.set(id, e)\n    if (!!e.getCoalescedEvents) for (let ev of e.getCoalescedEvents()) {\n      onUpdate(id, RawPoint.fromEvent(ev, pressure))\n    } else {\n      onUpdate(id, RawPoint.fromEvent(e, pressure))\n    }\n  }\n}\n\n$svg.onpointerup = $svg.onpointerout = (e) => {\n  let id = e.pointerId\n  e.preventDefault()\n  e.stopPropagation()\n  if (running.has(id)) {\n    if (!!e.getPredictedEvents) {\n      // Use last point's predict result instead of this pointerup event.\n      let ev = running.get(id)!.getPredictedEvents()[0]\n      if (ev) onUpdate(id, RawPoint.fromEvent(ev, pressure))\n    }\n    onClose(id)\n    running.delete(id)\n  }\n}\n\n$svg.onpointercancel = (e) => {\n  let id = e.pointerId\n  e.preventDefault()\n  e.stopPropagation()\n  if (running.has(id)) {\n    onCancel(id)\n    running.delete(id)\n  }\n}\n\n$svg.ontouchstart = $svg.ontouchmove = $svg.ontouchend = $svg.ontouchcancel = (e) => {\n  e.preventDefault()\n  e.stopPropagation()\n}\n\nlet eraserLastPoint: RawPoint | undefined\n\n$mask.onpointerdown = (e) => {\n  e.preventDefault()\n  e.stopPropagation()\n  $mask.setPointerCapture(e.pointerId)\n  onErase(eraserLastPoint = RawPoint.fromEvent(e))\n}\n\n$mask.onpointermove = (e) => {\n  if (eraserLastPoint) {\n    e.preventDefault()\n    e.stopPropagation()\n    let current = RawPoint.fromEvent(e)\n    onErase(current)\n    eraserLastPoint = current\n  }\n}\n\n$mask.onpointerup = $mask.onpointerout = (e) => {\n  eraserLastPoint = void 0\n}\n\n$mask.ontouchstart = $mask.ontouchmove = $mask.ontouchend = $mask.ontouchcancel = (e) => {\n  e.preventDefault()\n  e.stopPropagation()\n}\n\nlet undoStack = {\n  index: 0,\n  stack: [],\n  get undoable() { return this.index > 0 },\n  get redoable() { return this.index < this.stack.length },\n  commit(undo: () => void, redo: () => void) {\n    this.stack[this.index] = { undo, redo }\n    this.index++\n    // Max 20 steps.\n    while (this.stack.length > 20) {\n      this.stack.shift()\n      this.index--\n    }\n    // Delete all redos.\n    this.stack.length = this.index\n    this.update()\n  },\n  undo() {\n    if (this.undoable) {\n      this.index--\n      this.stack[this.index].undo()\n      this.update()\n    }\n  },\n  redo() {\n    if (this.redoable) {\n      this.stack[this.index].redo()\n      this.index++\n      this.update()\n    }\n  },\n  update() {\n    $settings.undo.disabled = !this.undoable\n    $settings.redo.disabled = !this.redoable\n  }\n}\n\nlet strokes: { [id: number]: [Stroke, SVGPathElement] } = {}\nlet dirty: { [id: number]: true } = {}\n\nlet onOpen = (id: number, p: RawPoint) => {\n  let stroke = Stroke.of([p])\n  let $path = $svg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'path'))\n  $path.style.pointerEvents = 'none'\n  $path.style.fill = $settings.color.value\n  strokes[id] = [stroke, $path]\n  dirty[id] = true\n  render()\n}\n\nlet onUpdate = (id: number, p: RawPoint) => {\n  if (strokes[id]) {\n    strokes[id][0].push(p)\n    dirty[id] = true\n    render()\n    requestAnimation()\n  }\n}\n\nlet onCancel = (id: number) => {\n  if (strokes[id]) {\n    strokes[id][1].remove()\n    delete strokes[id]\n    delete dirty[id]\n  }\n}\n\nlet onClose = (id: number) => {\n  if (strokes[id]) {\n    let [stroke, $path] = strokes[id]\n    let commit = true\n    if (stroke.empty && !stroke.dot) {\n      $path.remove()\n      commit = false\n    }\n    render()\n    delete dirty[id]\n    requestAnimation()\n    if (commit) undoStack.commit(\n      () => $path.remove(),\n      // The z-index is not correct, but this demo does not care about it.\n      () => $svg.append($path),\n    )\n  }\n}\n\nlet onErase = (p: RawPoint) => {\n  let point = $svg.createSVGPoint()\n  point.x = p.x\n  point.y = p.y\n  for (let $path of $svg.children as unknown as SVGPathElement[]) {\n    $path.isPointInFill(point) && $path.remove()\n  }\n  if (eraserLastPoint) {\n    let dx = p.x - eraserLastPoint.x, dy = p.y - eraserLastPoint.y\n    for (let x = 0; x < 1; x += 0.1) {\n      let point = $svg.createSVGPoint()\n      point.x = p.x - x * dx\n      point.y = p.y - x * dy\n      for (let $path of $svg.children as unknown as SVGPathElement[]) {\n        $path.isPointInFill(point) && $path.remove()\n      }\n    }\n  }\n}\n\n// This happens synchronously, without even a microtask.\nlet render = () => {\n  let size = $settings.size.valueAsNumber\n  for (let id in dirty) {\n    if (strokes[id]) {\n      let [stroke, $path] = strokes[id], d = ''\n      for (let index of stroke.segments) {\n        let outline = stroke.outline(index, size)\n        d += stroke.stroke(outline)\n      }\n      $path.setAttribute('d', d)\n    }\n    delete dirty[id]\n  }\n}\n\nlet animateId = 0\n\nlet requestAnimation = () => {\n  cancelAnimationFrame(animateId)\n  animateId = requestAnimationFrame(updateAnimation)\n}\n\nlet updateAnimation = () => {\n  render()\n  let schedule = false\n  for (let id in strokes) {\n    if (strokes[id][0].isSpreading()) {\n      dirty[id] = true\n      schedule = true\n    }\n  }\n  if (schedule) requestAnimation()\n}\n\nlet isMac = /Mac/.test(navigator.platform)\n\ndocument.onkeydown = (ev) => {\n  let ctrl = ev.ctrlKey, shift = ev.shiftKey, meta = ev.metaKey, alt = ev.altKey, code = ev.keyCode\n  let primary = isMac ? meta : ctrl\n\n  const click = (btn: HTMLInputElement | HTMLButtonElement) => {\n    ev.preventDefault()\n    btn.focus(); btn.click()\n  }\n\n  if (!ctrl && !shift && !meta && !alt) {\n    if (code == 80)\n      if ($settings.eraser.checked)\n        click($settings.eraser)\n      else\n        click($settings.pressure)\n    if (code == 69) click($settings.eraser) \n    if (code == 219 || code == 221) {\n      let size = $settings.size.valueAsNumber, inc = code == 221 ? 5 : -5\n      $settings.size.value = '' + clamp(size + inc, +$settings.size.min, +$settings.size.max)\n    }\n  } else if (primary && !shift && code == 90) {\n    click($settings.undo)\n  } else if (primary && shift && code == 90) {\n    click($settings.redo)\n  }\n}\n\nObject.assign(globalThis, {\n  $settings, $svg, strokes, dirty, undoStack,\n})\n"],"names":["clamp","value","min","max","Vec","x","y","vec","other","scalar","d","center","radius","s","c","px","py","nx","ny","t","Spring","target","dt","delta","velocity","spring","damper","acceleration","RawPoint","p","pressure","timestamp","event","json","Point","v","l","point","vector","distance","length","pressureTillNow","now","pressureTillNow2","Stroke","points","raw","stroke","from","prev","size","end","leftPoints","rightPoints","prevPressure","drawEndCap","prevTimestamp","p2","i","sp","rp","nextVector","nextDot","offset","pl","pr","startCap","firstPoint","endCap","step","lastPoint","direction","start","circle","n","path","curr","middle","segments","$root","$svg","$mask","$settings","current","undoStack","erasing","running","id","onOpen","e0","ev","onUpdate","onClose","onCancel","eraserLastPoint","onErase","undo","redo","strokes","dirty","$path","render","requestAnimation","commit","dx","dy","index","outline","animateId","updateAnimation","schedule","isMac","ctrl","shift","meta","alt","code","primary","click","btn","inc"],"mappings":"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"}
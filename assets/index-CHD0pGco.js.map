{"version":3,"file":"index-CHD0pGco.js","sources":["../../src/vec.ts","../../src/ink.ts","../../main.ts"],"sourcesContent":["/// 2D vector\nexport interface Vec {\n  readonly x: number\n  readonly y: number\n}\n\nexport const norm = ({ x, y }: Vec, d = Math.hypot(x, y)): Vec => ({ x: x / d, y: y / d })\nexport const add = (a: Vec, b: Vec): Vec => ({ x: a.x + b.x, y: a.y + b.y })\nexport const sub = (a: Vec, b: Vec): Vec => ({ x: a.x - b.x, y: a.y - b.y })\nexport const mul = (a: Vec, n: number): Vec => ({ x: a.x * n, y: a.y * n })\nexport const per = ({ x, y }: Vec): Vec => ({ x: y, y: -x })\nexport const neg = ({ x, y }: Vec): Vec => ({ x: -x, y: -y })\nexport const mid = (a: Vec, b: Vec): Vec => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 })\n\n/// Rotate point `(x, y)` around point `C` in raidus `r`.\nexport const rot = ({ x, y }: Vec, C: Vec, r: number) => {\n  const s = Math.sin(r), c = Math.cos(r),\n        px = x - C.x, py = y - C.y,\n        nx = px * c - py * s,\n        ny = px * s + py * c\n  return { x: nx + C.x, y: ny + C.y }\n}\n\nexport const dot = (a: Vec, b: Vec) => a.x * b.x + a.y * b.y\nexport const lerp = (a: Vec, b: Vec, t: number) => add(a, mul(sub(b, a), t))\nexport const proj = (a: Vec, b: Vec, c: number) => add(a, mul(b, c))\n\nexport const copy = (a: Vec, b: Vec) => {\n  (a as { x: number }).x = b.x;\n  (a as { y: number }).y = b.y\n  return a\n}\n","import { add, dot, lerp, mul, neg, norm, per, proj, rot, sub, type Vec } from './vec'\n\nexport type { Vec }\n\n// Internal constants, I don't plan to expose them as options.\nconst enum C {\n  // SAI-like input smoothing strategy: keep a queue of points\n  // and get middle of them. The queue size is `Smoothing + 1`.\n  Smoothing = 1,\n  // Skip points that are too close.\n  SkipDistance = 5,\n  // If |segment| < `MinDistance` and is sharp corner, split here\n  // and skip next `CoolingDown` points for performance.\n  // `CoolingDown` must > 0.\n  MinDistance = 1000, CoolingDown = 1,\n  // If the last |segment| > `TailDistance * size`, draw a thinner tail,\n  // otherwise draw an end cap.\n  TailDistance = 0.4,\n  // Math.PI + 0.0001 to prevent floating number issue when drawing the cap.\n  PI = 3.1416926535897933,\n  // Simulate pressure for mouse and trackpad.\n  PressureChangeSpeed = 0.3,\n  // Approximate ratio that multiplies `size` to draw a dot.\n  DotSize = 0.36,\n  // Minimal stroke width / 2.\n  MinRadius = 0.75,\n}\n\nexport interface RawPoint extends Vec {\n  readonly r: number\n}\n\n/// The data structure for a point with its context information.\nclass Point {\n  /// @internal\n  constructor(\n    /// The point's position.\n    readonly p: Vec,\n    /// Radius or pressure.\n    readonly r: number,\n    /// The inverted direction of this point, equals to `previous - current`.\n    /// The first point's `v` is a dummy value.\n    readonly v: Vec,\n    /// Distance to previous point, equals to `hypot(previous - current)`.\n    readonly d: number,\n    /// Running length, the last point's `l` is the stroke's approximate length.\n    readonly l: number,\n  ) {}\n\n  /// @internal\n  toJSON(): any {\n    return [this.p.x, this.p.y, this.r]\n  }\n\n  /// @internal Returns a shallow copy of this point, with raidus changed.\n  dup(r = this.r): Point {\n    return new Point(this.p, r, this.v, this.d, this.l)\n  }\n}\n\n/// The data structure for a single stroke, which contains many points.\nexport class Stroke {\n  /// Indexes to split `points` into curves. The first index is always `0`.\n  readonly sections: number[] = [0]\n  /// @internal See `insert()`.\n  readonly pending: { [from: number]: RawPoint[] } = { __proto__: null } as any\n  /// @internal See `updateCurr()`.\n  readonly queue: Vec[] = []\n\n  /// @internal\n  constructor(\n    /// The stroke's points. It is guaranteed that this is a grow-only immutable array.\n    readonly points: Point[],\n    /// The stroke's length, equals to `points.at(-1).l`.\n    /// `insert()` and `push()` will update this value.\n    readonly length = points.length > 0 ? points[points.length - 1].l : 0,\n  ) {\n    this.updateSections()\n  }\n\n  /// True when `points` is empty.\n  get empty(): boolean { return this.points.length == 0 }\n\n  /// True when `points` contains exactly one element.\n  get dot(): boolean { return this.points.length == 1 }\n\n  /// Update the stroke with new points inserted from `from`.\n  /// `from` can exceed `points.length`, where the points will be\n  /// pending unless there are new points fill in the hole.\n  insert(from: number, raw: RawPoint[]): void {\n    if (from == this.points.length) {\n      raw.forEach(p => this.push(p, true))\n      from = this.points.length\n      if ((raw = this.pending[from])) {\n        delete this.pending[from]\n        this.insert(from, raw)\n      }\n      // Recursively call `insert()` to flush pending points.\n      // Ensure `updateSections()` is called at the end or recursion.\n      else {\n        this.updateSections()\n      }\n    }\n    else if (from > this.points.length) {\n      if (__DEV__ && this.pending[from])\n        console.warn(`Override pending points from ${from}`)\n      this.pending[from] = raw\n    }\n    else {\n      throw new RangeError(`Position ${from} conflicts with existing points`)\n    }\n  }\n\n  /// Update the stroke with new point appended to the end of `points`.\n  /// If `skip_sections` is `true`, it will not update `sections`.\n  push(p: RawPoint, skip_sections = false): void {\n    let { points } = this\n    if (points.length > 0) {\n      let curr: RawPoint, prev_ = points[points.length-1]\n      // @ts-ignore No smoothing, get the raw input.\n      if (C.Smoothing == 0) curr = p\n      // @ts-ignore Level-1 smoothing, get the center of each segment.\n      else if (C.Smoothing == 1)\n        curr = { x: (p.x + prev_.p.x) / 2, y: (p.y + prev_.p.y) / 2, r: p.r }\n      // Level-N smoothing\n      else {\n        curr = this.updateCurr(p, C.Smoothing + 1)\n      }\n      let prev = prev_.p, d = Math.hypot(curr.x - prev.x, curr.y - prev.y);\n      this.updateLength(d)\n      if (this.length - prev_.l < C.SkipDistance) {\n        // Skip this point, but preserve its pressure.\n        (prev_ as { r: number }).r = Math.max(prev_.r, curr.r)\n        return\n      }\n      points.push(new Point(curr, curr.r, norm(sub(prev, curr)), d, this.length))\n      if (!skip_sections) this.updateSections()\n    }\n    else {\n      points.push(new Point(p, p.r, { x: 1, y: 1 }, 0, 0))\n    }\n  }\n\n  /// Compute the outline points of the section starting at `from`.\n  /// Returns an empty array if `from` is not zero and not in `sections`.\n  /// `size` is the full width when pressure is 1.\n  outline(from: number, size: number): Vec[] {\n    let end = this.sections.find(end => from < end)\n    // Get one more point at head to connect curves.\n    let points = this.points.slice(from > 0 ? from - 1 : from, end)\n    if (points.length > 1) {\n      let leftPoints: Vec[] = [], rightPoints: Vec[] = [], len = points.length,\n          radius = size, prevPressure = points[0].r, drawEndCap = true\n      // If `end` is `undefined`, this is the final section. Draw a thinner tail when possible.\n      // The precisely comparing to `0.5` is probably a mouse event (i.e. no real pressure).\n      if (end == null && points[len - 1].r == 0.5 && points[len - 1].d > C.TailDistance * size) {\n        if (len - 1 >= 0) points[len - 1] = points[len - 1].dup(Math.max(0.1, points[len - 1].r - 0.4))\n        if (len - 2 >= 0) points[len - 2] = points[len - 2].dup(Math.max(0.1, points[len - 2].r - 0.2))\n        drawEndCap = false\n      }\n      // Simulate pressure and push left/right points.\n      for (let i = 0; i < len; i++) {\n        let { p, r, v, d } = points[i]\n        // Fix first point's distance and direction (assume the same as the next point).\n        if (i == 0) {\n          d = 0\n          if (i < len - 1) v = points[i + 1].v\n        }\n        let sp = Math.min(1, d / size), rp = Math.min(1, 1 - sp),\n            pressure = Math.min(1, prevPressure + (rp - prevPressure) * (sp * C.PressureChangeSpeed)),\n            nextVector = (i < len - 1 ?  points[i + 1] : points[i]).v,\n            nextDot = i < len - 1 ? dot(v, nextVector) : 1\n\n        radius = Math.max(size * (0.5 * pressure), C.MinRadius)\n\n        let offset = mul(per(lerp(nextVector, v, nextDot)), radius)\n        let pl = sub(p, offset); leftPoints.push(pl)\n        let pr = add(p, offset); rightPoints.push(pr)\n\n        prevPressure = r\n      }\n      let startCap: Vec[] = [], endCap: Vec[] = []\n      for (let step = 1 / 13, t = step; t <= 1; t += step) {\n        startCap.push(rot(rightPoints[0], points[0].p, C.PI * t))\n      }\n      if (drawEndCap) {\n        let lastPoint = points[len - 1],\n            direction = per(neg(lastPoint.v)),\n            start = proj(lastPoint.p, direction, radius)\n        for (let step = 1 / 13, t = step; t < 1; t += step) {\n          endCap.push(rot(start, lastPoint.p, C.PI * t))\n        }\n      }\n      return leftPoints.concat(endCap, rightPoints.reverse(), startCap)\n    }\n    // Dot case.\n    else if (points.length == 1) {\n      let lastPoint = points[0],\n          direction = per(neg(lastPoint.v)),\n          start = proj(lastPoint.p, direction, size * C.DotSize * lastPoint.r),\n          circle: Vec[] = []\n      for (let step = 1 / 13, t = 0; t <= 2; t += step) {\n        circle.push(rot(start, lastPoint.p, C.PI * t))\n      }\n      return circle\n    }\n    else {\n      return []\n    }\n  }\n\n  /// @internal Increment `length`.\n  private updateLength(d: number) {\n    (this as { length: number }).length += d\n  }\n\n  /// @internal Update `sections` incrementally using current `points`.\n  private updateSections() {\n    let { sections } = this;\n    // The first 2 points share the same vector, skip them.\n    for (let i = sections.length > 1 ? (sections[sections.length-1] + C.CoolingDown) : 2,\n             len = this.points.length; i < len; i++) {\n      if (this.points[i].d < C.MinDistance &&\n          dot(this.points[i].v, this.points[i-1].v) < 0) {\n        sections.push(i)\n        i += C.CoolingDown\n      }\n    }\n  }\n\n  /// @internal\n  private updateCurr(p: RawPoint, n: number): RawPoint {\n    this.queue.push(p)\n    while (this.queue.length > n)\n      this.queue.shift()\n    let x = 0, y = 0\n    for (let q of this.queue) {\n      x += q.x\n      y += q.y\n    }\n    n = this.queue.length\n    return { x: x / n, y: y / n, r: p.r }\n  }\n\n  /// Convert this stroke to a JSON-serializable object.\n  toJSON(): any {\n    return this.points.map(p => p.toJSON())\n  }\n\n  /// De-serialize a stroke from its JSON representation.\n  static fromJSON(json: any): Stroke {\n    if (!json || !Array.isArray(json))\n      throw new RangeError(\"Invalid JSON representation for Stroke\")\n    return Stroke.create(json.map(a => ({ x: a[0], y: a[1], r: a[2] })))\n  }\n\n  /// Create a new stroke from raw input.\n  static create(raw: RawPoint[] = []): Stroke {\n    let points: Point[] = [], ll = 0\n    if (raw.length > 0) {\n      let prev = raw[0], l = 0\n      points.push(new Point(prev, prev.r, { x: 1, y: 1 }, 0, 0))\n      for (let i = 1; i < raw.length; i++) {\n        let curr = raw[i], d = Math.hypot(curr.x - prev.x, curr.y - prev.y)\n        l += d\n        if (l - ll < C.SkipDistance) {\n          // Skip this point and keep pressure.\n          (points[points.length - 1] as { r: number }).r = curr.r\n          continue;\n        }\n        points.push(new Point(curr, curr.r, norm(sub(prev, curr)), d, l))\n        prev = curr\n        ll = l\n      }\n    }\n    return new Stroke(points, ll)\n  }\n}\n","import { Stroke, type Vec } from './src/ink'\n\nlet $root = document.getElementById('app')!\nlet $svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\nlet $g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\nlet $settings = {\n  size: document.getElementById('stroke-size') as HTMLInputElement,\n  clear: document.getElementById('clear') as HTMLButtonElement,\n  undo: document.getElementById('undo') as HTMLButtonElement,\n  redo: document.getElementById('redo') as HTMLButtonElement,\n  outline: document.getElementById('outline') as HTMLInputElement,\n  data: document.getElementById('data') as HTMLElement,\n}\n\nlet total = 0\nfunction updateData(stroke: Stroke) {\n  try {\n    let bytes = JSON.stringify(stroke.toJSON()).length\n    total += bytes\n    $settings.data.textContent = `${prettyBytes(bytes)} (Total: ${prettyBytes(total)})`\n  } catch (err) {\n    console.error(err)\n  }\n}\n\nfunction prettyBytes(n: number) {\n  return n < 1024 ? n + ' B' : (n / 1024).toFixed(1) + ' kB'\n}\n\nlet undoStack = {\n  index: 0,\n  // Suppose we have committed 2 strokes:\n  //\n  //   stack = [delete_stroke_1, delete_stroke_2]\n  //                                            ^ index = 2\n  // Now call `undo()`, what happens is index--:\n  //\n  //   stack = [delete_stroke_1, restore_stroke_2]\n  //                           ^ index = 1\n  //                             ^^^^^^^^^^^^^^^^ replace the undo() with redo()\n  stack: [],\n  get undoable(): boolean { return this.index > 0 },\n  get redoable(): boolean { return this.index < this.stack.length },\n  commit(undo: () => void, redo: () => void) {\n    this.stack[this.index] = { undo, redo }\n    this.index += 1\n    // Max 20 steps.\n    while (this.stack.length > 20) {\n      this.stack.shift()\n      this.index -= 1\n    }\n    // Clear all redos.\n    this.stack.length = this.index\n    this.update()\n  },\n  undo() {\n    if (this.undoable) {\n      this.index -= 1\n      this.stack[this.index].undo()\n      this.update()\n    }\n  },\n  redo() {\n    if (this.redoable) {\n      this.stack[this.index].redo()\n      this.index += 1\n      this.update()\n    }\n  },\n  update() {\n    $settings.undo.disabled = !this.undoable\n    $settings.redo.disabled = !this.redoable\n  },\n}\n\n$svg.append($g)\n$root.append($svg)\n\n$settings.clear.onclick = () => {\n  let current = Array.from($g.children)\n  $g.textContent = ''\n  undoStack.commit(\n    () => $g.append(...current),\n    () => $g.textContent = '',\n  )\n}\n\n$settings.undo.onclick = () => undoStack.undo()\n$settings.redo.onclick = () => undoStack.redo()\n\nlet rect: DOMRect\n\n$g.setAttribute('fill', 'currentColor')\n$settings.outline.oninput = () => {\n  let outline = $settings.outline.checked\n  if (outline) {\n    $g.setAttribute('fill', 'none')\n    $g.setAttribute('stroke', 'currentColor')\n    $g.setAttribute('stroke-width', '1')\n  } else {\n    $g.setAttribute('fill', 'currentColor')\n  }\n}\n\n$svg.setAttribute('fill-rule', 'nonzero')\n$svg.style.cssText = 'display: block; width: 100%; height: 100%; font-size: 0; touch-action: none; position: relative; contain: content'\n\nlet scheduled = false\nlet strokes = { __proto__: null } as { [id: number]: [s: Stroke, p: SVGPathElement, x: number, y: number, pred?: PointerEvent | null] }\nlet dirty = { __proto__: null } as { [id: number]: true }\n\n$svg.onpointerdown = (ev) => {\n  ev.preventDefault()\n  ev.stopPropagation()\n  $svg.setPointerCapture(ev.pointerId)\n  rect = $svg.getBoundingClientRect()\n  let stroke = Stroke.create([{ x: ev.clientX - rect.left, y: ev.clientY - rect.top, r: ev.pressure }])\n  let $path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n  $path.style.pointerEvents = 'none'\n  strokes[ev.pointerId] = [stroke, $path, ev.clientX, ev.clientY]\n  dirty[ev.pointerId] = true\n  $g.append($path)\n  if (scheduled) return;\n  scheduled = true\n  queueMicrotask(render)\n}\n\n$svg.onpointermove = (ev) => {\n  ev.preventDefault()\n  ev.stopPropagation()\n  if (strokes[ev.pointerId]) {\n    let [stroke, _path, x_, y_] = strokes[ev.pointerId]\n\n    // Apple pencil's bug, it fires 2 identical events.\n    // For pressure-change-only events, it seems chrome will emit a point that slightly changes position (x+1).\n    // So this workaround does not cause other issues.\n    if (x_ == ev.clientX && y_ == ev.clientY) return;\n    strokes[ev.pointerId][2] = ev.clientX\n    strokes[ev.pointerId][3] = ev.clientY\n\n    // Firefox sometimes give 0 to mousemove events, fix them to 0.5.\n    let pressure: number | undefined\n    if (ev.pointerType === 'mouse' && pressure == 0) pressure = 0.5\n\n    // @ts-ignore\n    if (ev.getCoalescedEvents) ev.getCoalescedEvents().forEach(e => {\n      stroke.push({ x: e.clientX - rect.left, y: e.clientY - rect.top, r: pressure ?? e.pressure })\n    })\n    else {\n      stroke.push({ x: ev.clientX - rect.left, y: ev.clientY - rect.top, r: pressure ?? ev.pressure })\n    }\n    dirty[ev.pointerId] = true\n\n    // @ts-ignore\n    if (ev.getPredictedEvents) {\n      strokes[ev.pointerId][4] = ev.getPredictedEvents()[0]\n    }\n\n    if (scheduled) return;\n    scheduled = true\n    queueMicrotask(render)\n  }\n}\n\n$svg.onpointercancel = (ev) => {\n  ev.preventDefault()\n  ev.stopPropagation()\n  if (strokes[ev.pointerId]) {\n    strokes[ev.pointerId][1].remove()\n    delete strokes[ev.pointerId]\n  }\n}\n\n$svg.onpointerup = $svg.onpointerout = (ev) => {\n  ev.preventDefault()\n  ev.stopPropagation()\n  if (strokes[ev.pointerId]) {\n    let [stroke, $path, x_, y_, e] = strokes[ev.pointerId]\n    let commit = true\n    if (e && (e.clientX != x_ || e.clientY != y_)) {\n      stroke.push({\n        x: Math.round(e.clientX - rect.left),\n        y: Math.round(e.clientY - rect.top),\n        r: Math.max(e.pressure, 0.1),\n      })\n      dirty[e.pointerId] = true\n      render()\n    }\n    // If this stroke is too small to be seen, remove it\n    else if (stroke.empty) {\n      $path.remove()\n      commit = false\n    }\n    console.log(stroke)\n    updateData(stroke)\n    delete strokes[ev.pointerId]\n    if (commit) {\n      undoStack.commit(\n        () => $path.remove(),\n        // The z-index is not correct, but this demo does not care about it.\n        () => $g.append($path),\n      )\n    }\n  }\n}\n\n$svg.ontouchstart = $svg.ontouchmove = $svg.ontouchend = $svg.ontouchcancel = (ev) => {\n  ev.preventDefault()\n  ev.stopPropagation()\n}\n\nconst mid = (a: Vec, b: Vec): Vec => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 })\nconst M = ({ x, y }) => `M${x.toFixed(2)},${y.toFixed(2)}`;\nconst L = ({ x, y }) => `L${x.toFixed(2)},${y.toFixed(2)}`;\nconst Q = (c, { x, y }) => `Q${c.x.toFixed(2)},${c.y.toFixed(2)} ${x.toFixed(2)},${y.toFixed(2)}`;\n\nfunction render() {\n  scheduled = false\n  let size = $settings.size.valueAsNumber\n  for (let id in dirty) if (strokes[id]) {\n    let [stroke, $path] = strokes[id], d = ''\n    for (let index of stroke.sections) {\n      d += simple_bezier(stroke.outline(index, size))\n    }\n    $path.setAttribute('d', d)\n  }\n  dirty = { __proto__: null } as typeof dirty\n}\n\nfunction simple_bezier(points: Vec[]) {\n  if (points.length == 0) return '';\n  let prev = points.shift()!, d = M(prev), i = 1;\n  for (let curr of points) {\n    if (i) d += L(mid(prev, curr))\n    d += Q(prev, mid(prev, curr))\n    i = 0\n    prev = curr\n  }\n  return d + L(points[points.length - 1])\n}\n"],"names":["norm","x","y","d","add","a","b","sub","mul","n","per","neg","rot","C","r","s","c","px","py","nx","ny","dot","lerp","t","proj","Point","p","v","l","Stroke","points","length","from","raw","skip_sections","curr","prev_","prev","size","end","leftPoints","rightPoints","len","radius","prevPressure","drawEndCap","i","sp","rp","pressure","nextVector","nextDot","offset","pl","pr","startCap","endCap","step","lastPoint","direction","start","circle","sections","q","json","ll","$root","$svg","$g","$settings","total","updateData","stroke","bytes","prettyBytes","err","undoStack","undo","redo","current","rect","scheduled","strokes","dirty","ev","$path","render","_path","x_","y_","e","commit","mid","M","L","Q","id","index","simple_bezier"],"mappings":"AAMO,MAAMA,EAAO,CAAC,CAAE,EAAAC,EAAG,EAAAC,CAAE,EAAQC,EAAI,KAAK,MAAMF,EAAGC,CAAC,KAAY,CAAE,EAAGD,EAAIE,EAAG,EAAGD,EAAIC,CAAE,GAC3EC,EAAM,CAACC,EAAQC,KAAiB,CAAE,EAAGD,EAAE,EAAIC,EAAE,EAAG,EAAGD,EAAE,EAAIC,EAAE,CAAE,GAC7DC,EAAM,CAACF,EAAQC,KAAiB,CAAE,EAAGD,EAAE,EAAIC,EAAE,EAAG,EAAGD,EAAE,EAAIC,EAAE,CAAE,GAC7DE,EAAM,CAACH,EAAQI,KAAoB,CAAE,EAAGJ,EAAE,EAAII,EAAG,EAAGJ,EAAE,EAAII,CAAE,GAC5DC,EAAM,CAAC,CAAE,EAAAT,EAAG,EAAAC,MAAmB,CAAE,EAAGA,EAAG,EAAG,CAACD,CAAE,GAC7CU,EAAM,CAAC,CAAE,EAAAV,EAAG,EAAAC,MAAmB,CAAE,EAAG,CAACD,EAAG,EAAG,CAACC,CAAE,GAI9CU,EAAM,CAAC,CAAE,EAAAX,EAAG,EAAAC,CAAE,EAAQW,EAAQC,IAAc,CACjD,MAAAC,EAAI,KAAK,IAAID,CAAC,EAAGE,EAAI,KAAK,IAAIF,CAAC,EAC/BG,EAAKhB,EAAIY,EAAE,EAAGK,EAAKhB,EAAIW,EAAE,EACzBM,EAAKF,EAAKD,EAAIE,EAAKH,EACnBK,EAAKH,EAAKF,EAAIG,EAAKF,EAClB,MAAA,CAAE,EAAGG,EAAKN,EAAE,EAAG,EAAGO,EAAKP,EAAE,EAClC,EAEaQ,EAAM,CAAChB,EAAQC,IAAWD,EAAE,EAAIC,EAAE,EAAID,EAAE,EAAIC,EAAE,EAC9CgB,EAAO,CAACjB,EAAQC,EAAQiB,IAAcnB,EAAIC,EAAGG,EAAID,EAAID,EAAGD,CAAC,EAAGkB,CAAC,CAAC,EAC9DC,EAAO,CAACnB,EAAQC,EAAQU,IAAcZ,EAAIC,EAAGG,EAAIF,EAAGU,CAAC,CAAC,ECQnE,MAAMS,CAAM,CAEV,YAEWC,EAEAZ,EAGAa,EAEAxB,EAEAyB,EACT,CAVS,KAAA,EAAAF,EAEA,KAAA,EAAAZ,EAGA,KAAA,EAAAa,EAEA,KAAA,EAAAxB,EAEA,KAAA,EAAAyB,CACR,CAGH,QAAc,CACL,MAAA,CAAC,KAAK,EAAE,EAAG,KAAK,EAAE,EAAG,KAAK,CAAC,CACpC,CAGA,IAAId,EAAI,KAAK,EAAU,CACd,OAAA,IAAIW,EAAM,KAAK,EAAGX,EAAG,KAAK,EAAG,KAAK,EAAG,KAAK,CAAC,CACpD,CACF,CAGO,MAAMe,CAAO,CASlB,YAEWC,EAGAC,EAASD,EAAO,OAAS,EAAIA,EAAOA,EAAO,OAAS,CAAC,EAAE,EAAI,EACpE,CAJS,KAAA,OAAAA,EAGA,KAAA,OAAAC,EAZF,KAAA,SAAqB,CAAC,CAAC,EAEvB,KAAA,QAA0C,CAAE,UAAW,IAAK,EAErE,KAAS,MAAe,GAUtB,KAAK,eAAe,CACtB,CAGA,IAAI,OAAiB,CAAS,OAAA,KAAK,OAAO,QAAU,CAAE,CAGtD,IAAI,KAAe,CAAS,OAAA,KAAK,OAAO,QAAU,CAAE,CAKpD,OAAOC,EAAcC,EAAuB,CACtC,GAAAD,GAAQ,KAAK,OAAO,OACtBC,EAAI,QAAaP,GAAA,KAAK,KAAKA,EAAG,EAAI,CAAC,EACnCM,EAAO,KAAK,OAAO,QACdC,EAAM,KAAK,QAAQD,CAAI,IACnB,OAAA,KAAK,QAAQA,CAAI,EACnB,KAAA,OAAOA,EAAMC,CAAG,GAKrB,KAAK,eAAe,UAGfD,EAAO,KAAK,OAAO,OACX,KAAK,QAAQA,CAAI,GACtB,QAAA,KAAK,gCAAgCA,CAAI,EAAE,EAChD,KAAA,QAAQA,CAAI,EAAIC,MAGrB,OAAM,IAAI,WAAW,YAAYD,CAAI,iCAAiC,CAE1E,CAIA,KAAKN,EAAaQ,EAAgB,GAAa,CACzC,GAAA,CAAE,OAAAJ,CAAW,EAAA,KACb,GAAAA,EAAO,OAAS,EAAG,CACrB,IAAIK,EAAgBC,EAAQN,EAAOA,EAAO,OAAO,CAAC,EAKhDK,EAAO,CAAE,GAAIT,EAAE,EAAIU,EAAM,EAAE,GAAK,EAAG,GAAIV,EAAE,EAAIU,EAAM,EAAE,GAAK,EAAG,EAAGV,EAAE,GAKpE,IAAIW,EAAOD,EAAM,EAAGjC,EAAI,KAAK,MAAMgC,EAAK,EAAIE,EAAK,EAAGF,EAAK,EAAIE,EAAK,CAAC,EAEnE,GADA,KAAK,aAAalC,CAAC,EACf,KAAK,OAASiC,EAAM,EAAI,EAAgB,CAEzCA,EAAwB,EAAI,KAAK,IAAIA,EAAM,EAAGD,EAAK,CAAC,EACrD,MACF,CACAL,EAAO,KAAK,IAAIL,EAAMU,EAAMA,EAAK,EAAGnC,EAAKO,EAAI8B,EAAMF,CAAI,CAAC,EAAGhC,EAAG,KAAK,MAAM,CAAC,EACrE+B,GAAe,KAAK,eAAe,CAAA,MAGxCJ,EAAO,KAAK,IAAIL,EAAMC,EAAGA,EAAE,EAAG,CAAE,EAAG,EAAG,EAAG,CAAA,EAAK,EAAG,CAAC,CAAC,CAEvD,CAKA,QAAQM,EAAcM,EAAqB,CACzC,IAAIC,EAAM,KAAK,SAAS,KAAKA,GAAOP,EAAOO,CAAG,EAE1CT,EAAS,KAAK,OAAO,MAAME,EAAO,EAAIA,EAAO,EAAIA,EAAMO,CAAG,EAC1D,GAAAT,EAAO,OAAS,EAAG,CACrB,IAAIU,EAAoB,CAAA,EAAIC,EAAqB,CAAA,EAAIC,EAAMZ,EAAO,OAC9Da,EAASL,EAAMM,EAAed,EAAO,CAAC,EAAE,EAAGe,EAAa,GAGxDN,GAAO,MAAQT,EAAOY,EAAM,CAAC,EAAE,GAAK,IAAOZ,EAAOY,EAAM,CAAC,EAAE,EAAI,GAAiBJ,IAC9EI,EAAM,GAAK,IAAGZ,EAAOY,EAAM,CAAC,EAAIZ,EAAOY,EAAM,CAAC,EAAE,IAAI,KAAK,IAAI,GAAKZ,EAAOY,EAAM,CAAC,EAAE,EAAI,EAAG,CAAC,GAC1FA,EAAM,GAAK,IAAGZ,EAAOY,EAAM,CAAC,EAAIZ,EAAOY,EAAM,CAAC,EAAE,IAAI,KAAK,IAAI,GAAKZ,EAAOY,EAAM,CAAC,EAAE,EAAI,EAAG,CAAC,GACjFG,EAAA,IAGf,QAASC,EAAI,EAAGA,EAAIJ,EAAKI,IAAK,CAC5B,GAAI,CAAE,EAAApB,EAAG,EAAAZ,EAAG,EAAAa,EAAG,EAAAxB,GAAM2B,EAAOgB,CAAC,EAEzBA,GAAK,IACH3C,EAAA,EACA2C,EAAIJ,EAAM,IAAOf,EAAAG,EAAOgB,EAAI,CAAC,EAAE,IAErC,IAAIC,EAAK,KAAK,IAAI,EAAG5C,EAAImC,CAAI,EAAGU,EAAK,KAAK,IAAI,EAAG,EAAID,CAAE,EACnDE,EAAW,KAAK,IAAI,EAAGL,GAAgBI,EAAKJ,IAAiBG,EAAK,GAAsB,EACxFG,GAAcJ,EAAIJ,EAAM,EAAKZ,EAAOgB,EAAI,CAAC,EAAIhB,EAAOgB,CAAC,GAAG,EACxDK,EAAUL,EAAIJ,EAAM,EAAIrB,EAAIM,EAAGuB,CAAU,EAAI,EAEjDP,EAAS,KAAK,IAAIL,GAAQ,GAAMW,GAAW,GAAA,EAEvC,IAAAG,EAAS5C,EAAIE,EAAIY,EAAK4B,EAAYvB,EAAGwB,CAAO,CAAC,EAAGR,CAAM,EACtDU,EAAK9C,EAAImB,EAAG0B,CAAM,EAAGZ,EAAW,KAAKa,CAAE,EACvC,IAAAC,EAAKlD,EAAIsB,EAAG0B,CAAM,EAAGX,EAAY,KAAKa,CAAE,EAE7BV,EAAA9B,CACjB,CACA,IAAIyC,EAAkB,CAAA,EAAIC,EAAgB,GACjC,QAAAC,EAAO,EAAI,GAAIlC,EAAIkC,EAAMlC,GAAK,EAAGA,GAAKkC,EACpCF,EAAA,KAAK3C,EAAI6B,EAAY,CAAC,EAAGX,EAAO,CAAC,EAAE,EAAG,mBAAOP,CAAC,CAAC,EAE1D,GAAIsB,EAAY,CACd,IAAIa,EAAY5B,EAAOY,EAAM,CAAC,EAC1BiB,EAAYjD,EAAIC,EAAI+C,EAAU,CAAC,CAAC,EAChCE,EAAQpC,EAAKkC,EAAU,EAAGC,EAAWhB,CAAM,EACtC,QAAAc,EAAO,EAAI,GAAIlC,EAAIkC,EAAMlC,EAAI,EAAGA,GAAKkC,EAC5CD,EAAO,KAAK5C,EAAIgD,EAAOF,EAAU,EAAG,mBAAOnC,CAAC,CAAC,CAEjD,CACA,OAAOiB,EAAW,OAAOgB,EAAQf,EAAY,QAAA,EAAWc,CAAQ,CAAA,SAGzDzB,EAAO,QAAU,EAAG,CACvB,IAAA4B,EAAY5B,EAAO,CAAC,EACpB6B,EAAYjD,EAAIC,EAAI+C,EAAU,CAAC,CAAC,EAChCE,EAAQpC,EAAKkC,EAAU,EAAGC,EAAWrB,EAAO,IAAYoB,EAAU,CAAC,EACnEG,EAAgB,GACX,QAAAJ,EAAO,EAAI,GAAIlC,EAAI,EAAGA,GAAK,EAAGA,GAAKkC,EAC1CI,EAAO,KAAKjD,EAAIgD,EAAOF,EAAU,EAAG,mBAAOnC,CAAC,CAAC,EAExC,OAAAsC,CAAA,KAGP,OAAO,EAEX,CAGQ,aAAa1D,EAAW,CAC7B,KAA4B,QAAUA,CACzC,CAGQ,gBAAiB,CACnB,GAAA,CAAE,SAAA2D,CAAa,EAAA,KAEnB,QAAShB,EAAIgB,EAAS,OAAS,EAAKA,EAASA,EAAS,OAAO,CAAC,EAAI,EAAiB,EAC1EpB,EAAM,KAAK,OAAO,OAAQI,EAAIJ,EAAKI,IACtC,KAAK,OAAOA,CAAC,EAAE,EAAI,KACnBzB,EAAI,KAAK,OAAOyB,CAAC,EAAE,EAAG,KAAK,OAAOA,EAAE,CAAC,EAAE,CAAC,EAAI,IAC9CgB,EAAS,KAAKhB,CAAC,EACVA,GAAA,EAGX,CAGQ,WAAWpB,EAAa,EAAqB,CAE5C,IADF,KAAA,MAAM,KAAKA,CAAC,EACV,KAAK,MAAM,OAAS,GACzB,KAAK,MAAM,QACT,IAAAzB,EAAI,EAAGC,EAAI,EACN,QAAA6D,KAAK,KAAK,MACjB9D,GAAK8D,EAAE,EACP7D,GAAK6D,EAAE,EAET,SAAI,KAAK,MAAM,OACR,CAAE,EAAG9D,EAAI,EAAG,EAAGC,EAAI,EAAG,EAAGwB,EAAE,EACpC,CAGA,QAAc,CACZ,OAAO,KAAK,OAAO,IAASA,GAAAA,EAAE,QAAQ,CACxC,CAGA,OAAO,SAASsC,EAAmB,CACjC,GAAI,CAACA,GAAQ,CAAC,MAAM,QAAQA,CAAI,EACxB,MAAA,IAAI,WAAW,wCAAwC,EACxD,OAAAnC,EAAO,OAAOmC,EAAK,IAAU3D,IAAA,CAAE,EAAGA,EAAE,CAAC,EAAG,EAAGA,EAAE,CAAC,EAAG,EAAGA,EAAE,CAAC,GAAI,CAAC,CACrE,CAGA,OAAO,OAAO4B,EAAkB,GAAY,CACtC,IAAAH,EAAkB,CAAA,EAAImC,EAAK,EAC3B,GAAAhC,EAAI,OAAS,EAAG,CAClB,IAAII,EAAOJ,EAAI,CAAC,EAAGL,EAAI,EACvBE,EAAO,KAAK,IAAIL,EAAMY,EAAMA,EAAK,EAAG,CAAE,EAAG,EAAG,EAAG,CAAA,EAAK,EAAG,CAAC,CAAC,EACzD,QAASS,EAAI,EAAGA,EAAIb,EAAI,OAAQa,IAAK,CACnC,IAAIX,EAAOF,EAAIa,CAAC,EAAG3C,EAAI,KAAK,MAAMgC,EAAK,EAAIE,EAAK,EAAGF,EAAK,EAAIE,EAAK,CAAC,EAE9D,GADCT,GAAAzB,EACDyB,EAAIqC,EAAK,EAAgB,CAE1BnC,EAAOA,EAAO,OAAS,CAAC,EAAoB,EAAIK,EAAK,EACtD,QACF,CACAL,EAAO,KAAK,IAAIL,EAAMU,EAAMA,EAAK,EAAGnC,EAAKO,EAAI8B,EAAMF,CAAI,CAAC,EAAGhC,EAAGyB,CAAC,CAAC,EACzDS,EAAAF,EACF8B,EAAArC,CACP,CACF,CACO,OAAA,IAAIC,EAAOC,EAAQmC,CAAE,CAC9B,CACF,CCnRA,IAAIC,EAAQ,SAAS,eAAe,KAAK,EACrCC,EAAO,SAAS,gBAAgB,6BAA8B,KAAK,EACnEC,EAAK,SAAS,gBAAgB,6BAA8B,GAAG,EAC/DC,EAAY,CACd,KAAM,SAAS,eAAe,aAAa,EAC3C,MAAO,SAAS,eAAe,OAAO,EACtC,KAAM,SAAS,eAAe,MAAM,EACpC,KAAM,SAAS,eAAe,MAAM,EACpC,QAAS,SAAS,eAAe,SAAS,EAC1C,KAAM,SAAS,eAAe,MAAM,CACtC,EAEIC,EAAQ,EACZ,SAASC,EAAWC,EAAgB,CAC9B,GAAA,CACF,IAAIC,EAAQ,KAAK,UAAUD,EAAO,OAAA,CAAQ,EAAE,OACnCF,GAAAG,EACCJ,EAAA,KAAK,YAAc,GAAGK,EAAYD,CAAK,CAAC,YAAYC,EAAYJ,CAAK,CAAC,UACzEK,EAAK,CACZ,QAAQ,MAAMA,CAAG,CACnB,CACF,CAEA,SAASD,EAAYjE,EAAW,CACvB,OAAAA,EAAI,KAAOA,EAAI,MAAQA,EAAI,MAAM,QAAQ,CAAC,EAAI,KACvD,CAEA,IAAImE,EAAY,CACd,MAAO,EAUP,MAAO,CAAC,EACR,IAAI,UAAoB,CAAE,OAAO,KAAK,MAAQ,CAAE,EAChD,IAAI,UAAoB,CAAS,OAAA,KAAK,MAAQ,KAAK,MAAM,MAAO,EAChE,OAAOC,EAAkBC,EAAkB,CAIlC,IAHP,KAAK,MAAM,KAAK,KAAK,EAAI,CAAE,KAAAD,EAAM,KAAAC,GACjC,KAAK,OAAS,EAEP,KAAK,MAAM,OAAS,IACzB,KAAK,MAAM,QACX,KAAK,OAAS,EAGX,KAAA,MAAM,OAAS,KAAK,MACzB,KAAK,OAAO,CACd,EACA,MAAO,CACD,KAAK,WACP,KAAK,OAAS,EACd,KAAK,MAAM,KAAK,KAAK,EAAE,KAAK,EAC5B,KAAK,OAAO,EAEhB,EACA,MAAO,CACD,KAAK,WACP,KAAK,MAAM,KAAK,KAAK,EAAE,KAAK,EAC5B,KAAK,OAAS,EACd,KAAK,OAAO,EAEhB,EACA,QAAS,CACGT,EAAA,KAAK,SAAW,CAAC,KAAK,SACtBA,EAAA,KAAK,SAAW,CAAC,KAAK,QAClC,CACF,EAEAF,EAAK,OAAOC,CAAE,EACdF,EAAM,OAAOC,CAAI,EAEjBE,EAAU,MAAM,QAAU,IAAM,CAC9B,IAAIU,EAAU,MAAM,KAAKX,EAAG,QAAQ,EACpCA,EAAG,YAAc,GACPQ,EAAA,OACR,IAAMR,EAAG,OAAO,GAAGW,CAAO,EAC1B,IAAMX,EAAG,YAAc,EAAA,CAE3B,EAEAC,EAAU,KAAK,QAAU,IAAMO,EAAU,KAAK,EAC9CP,EAAU,KAAK,QAAU,IAAMO,EAAU,KAAK,EAE9C,IAAII,EAEJZ,EAAG,aAAa,OAAQ,cAAc,EACtCC,EAAU,QAAQ,QAAU,IAAM,CAClBA,EAAU,QAAQ,SAE3BD,EAAA,aAAa,OAAQ,MAAM,EAC3BA,EAAA,aAAa,SAAU,cAAc,EACrCA,EAAA,aAAa,eAAgB,GAAG,GAEhCA,EAAA,aAAa,OAAQ,cAAc,CAE1C,EAEAD,EAAK,aAAa,YAAa,SAAS,EACxCA,EAAK,MAAM,QAAU,oHAErB,IAAIc,EAAY,GACZC,EAAU,CAAE,UAAW,MACvBC,EAAQ,CAAE,UAAW,MAEzBhB,EAAK,cAAiBiB,GAAO,CAC3BA,EAAG,eAAe,EAClBA,EAAG,gBAAgB,EACdjB,EAAA,kBAAkBiB,EAAG,SAAS,EACnCJ,EAAOb,EAAK,wBACZ,IAAIK,EAAS3C,EAAO,OAAO,CAAC,CAAE,EAAGuD,EAAG,QAAUJ,EAAK,KAAM,EAAGI,EAAG,QAAUJ,EAAK,IAAK,EAAGI,EAAG,QAAU,CAAA,CAAC,EAChGC,EAAQ,SAAS,gBAAgB,6BAA8B,MAAM,EACzEA,EAAM,MAAM,cAAgB,OACpBH,EAAAE,EAAG,SAAS,EAAI,CAACZ,EAAQa,EAAOD,EAAG,QAASA,EAAG,OAAO,EACxDD,EAAAC,EAAG,SAAS,EAAI,GACtBhB,EAAG,OAAOiB,CAAK,EACX,CAAAJ,IACQA,EAAA,GACZ,eAAeK,CAAM,EACvB,EAEAnB,EAAK,cAAiBiB,GAAO,CAGvB,GAFJA,EAAG,eAAe,EAClBA,EAAG,gBAAgB,EACfF,EAAQE,EAAG,SAAS,EAAG,CACrB,GAAA,CAACZ,EAAQe,EAAOC,EAAIC,CAAE,EAAIP,EAAQE,EAAG,SAAS,EAKlD,GAAII,GAAMJ,EAAG,SAAWK,GAAML,EAAG,QAAS,OAC1CF,EAAQE,EAAG,SAAS,EAAE,CAAC,EAAIA,EAAG,QAC9BF,EAAQE,EAAG,SAAS,EAAE,CAAC,EAAIA,EAAG,QAG1B,IAAAnC,EAiBA,GAhBAmC,EAAG,cAAgB,SAAWnC,GAAY,IAAcA,EAAA,IAGxDmC,EAAG,mBAAuBA,EAAA,mBAAA,EAAqB,QAAaM,GAAA,CAC9DlB,EAAO,KAAK,CAAE,EAAGkB,EAAE,QAAUV,EAAK,KAAM,EAAGU,EAAE,QAAUV,EAAK,IAAK,EAAG/B,GAAYyC,EAAE,SAAU,CAAA,CAC7F,EAEClB,EAAO,KAAK,CAAE,EAAGY,EAAG,QAAUJ,EAAK,KAAM,EAAGI,EAAG,QAAUJ,EAAK,IAAK,EAAG/B,GAAYmC,EAAG,SAAU,EAE3FD,EAAAC,EAAG,SAAS,EAAI,GAGlBA,EAAG,qBACGF,EAAAE,EAAG,SAAS,EAAE,CAAC,EAAIA,EAAG,qBAAqB,CAAC,GAGlDH,EAAW,OACHA,EAAA,GACZ,eAAeK,CAAM,CACvB,CACF,EAEAnB,EAAK,gBAAmBiB,GAAO,CAC7BA,EAAG,eAAe,EAClBA,EAAG,gBAAgB,EACfF,EAAQE,EAAG,SAAS,IACtBF,EAAQE,EAAG,SAAS,EAAE,CAAC,EAAE,OAAO,EACzB,OAAAF,EAAQE,EAAG,SAAS,EAE/B,EAEAjB,EAAK,YAAcA,EAAK,aAAgBiB,GAAO,CAGzC,GAFJA,EAAG,eAAe,EAClBA,EAAG,gBAAgB,EACfF,EAAQE,EAAG,SAAS,EAAG,CACrB,GAAA,CAACZ,EAAQa,EAAOG,EAAIC,EAAIC,CAAC,EAAIR,EAAQE,EAAG,SAAS,EACjDO,EAAS,GACTD,IAAMA,EAAE,SAAWF,GAAME,EAAE,SAAWD,IACxCjB,EAAO,KAAK,CACV,EAAG,KAAK,MAAMkB,EAAE,QAAUV,EAAK,IAAI,EACnC,EAAG,KAAK,MAAMU,EAAE,QAAUV,EAAK,GAAG,EAClC,EAAG,KAAK,IAAIU,EAAE,SAAU,EAAG,CAAA,CAC5B,EACKP,EAAAO,EAAE,SAAS,EAAI,GACdJ,KAGAd,EAAO,QACda,EAAM,OAAO,EACJM,EAAA,IAEX,QAAQ,IAAInB,CAAM,EAClBD,EAAWC,CAAM,EACV,OAAAU,EAAQE,EAAG,SAAS,EACvBO,GACQf,EAAA,OACR,IAAMS,EAAM,OAAO,EAEnB,IAAMjB,EAAG,OAAOiB,CAAK,CAAA,CAG3B,CACF,EAEAlB,EAAK,aAAeA,EAAK,YAAcA,EAAK,WAAaA,EAAK,cAAiBiB,GAAO,CACpFA,EAAG,eAAe,EAClBA,EAAG,gBAAgB,CACrB,EAEA,MAAMQ,EAAM,CAACvF,EAAQC,KAAiB,CAAE,GAAID,EAAE,EAAIC,EAAE,GAAK,EAAG,GAAID,EAAE,EAAIC,EAAE,GAAK,CAAE,GACzEuF,EAAI,CAAC,CAAE,EAAA5F,EAAG,EAAAC,KAAQ,IAAID,EAAE,QAAQ,CAAC,CAAC,IAAIC,EAAE,QAAQ,CAAC,CAAC,GAClD4F,EAAI,CAAC,CAAE,EAAA7F,EAAG,EAAAC,KAAQ,IAAID,EAAE,QAAQ,CAAC,CAAC,IAAIC,EAAE,QAAQ,CAAC,CAAC,GAClD6F,GAAI,CAAC/E,EAAG,CAAE,EAAAf,EAAG,EAAAC,CAAA,IAAQ,IAAIc,EAAE,EAAE,QAAQ,CAAC,CAAC,IAAIA,EAAE,EAAE,QAAQ,CAAC,CAAC,IAAIf,EAAE,QAAQ,CAAC,CAAC,IAAIC,EAAE,QAAQ,CAAC,CAAC,GAE/F,SAASoF,GAAS,CACJL,EAAA,GACR,IAAA3C,EAAO+B,EAAU,KAAK,cAC1B,QAAS2B,KAAMb,EAAW,GAAAD,EAAQc,CAAE,EAAG,CACrC,GAAI,CAACxB,EAAQa,CAAK,EAAIH,EAAQc,CAAE,EAAG7F,EAAI,GAC9B,QAAA8F,KAASzB,EAAO,SACvBrE,GAAK+F,GAAc1B,EAAO,QAAQyB,EAAO3D,CAAI,CAAC,EAE1C+C,EAAA,aAAa,IAAKlF,CAAC,CAC3B,CACQgF,EAAA,CAAE,UAAW,KACvB,CAEA,SAASe,GAAcpE,EAAe,CACpC,GAAIA,EAAO,QAAU,EAAU,MAAA,GAC3B,IAAAO,EAAOP,EAAO,QAAU3B,EAAI0F,EAAExD,CAAI,EAAGS,EAAI,EAC7C,QAASX,KAAQL,EACXgB,IAAG3C,GAAK2F,EAAEF,EAAIvD,EAAMF,CAAI,CAAC,GAC7BhC,GAAK4F,GAAE1D,EAAMuD,EAAIvD,EAAMF,CAAI,CAAC,EACxBW,EAAA,EACGT,EAAAF,EAET,OAAOhC,EAAI2F,EAAEhE,EAAOA,EAAO,OAAS,CAAC,CAAC,CACxC"}
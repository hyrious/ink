{"version":3,"file":"index-PUxonKo1.js","sources":["../../src/base.ts","../../src/spring.ts","../../src/stroke.ts","../../main.ts"],"sourcesContent":["export const clamp = (value: number, min: number, max: number) => value < min ? min : value > max ? max : value;\n\nexport interface IPoint {\n  readonly x: number;\n  readonly y: number;\n}\n\nexport interface IRectangle extends IPoint {\n  readonly width: number;\n  readonly height: number;\n}\n\nexport class Vec {\n  /// @internal\n  constructor(\n    readonly x: number,\n    readonly y: number,\n  ) { }\n\n  static of(x: number, y: number) {\n    return new Vec(x, y);\n  }\n\n  static from(vec: IPoint) {\n    return new Vec(vec.x, vec.y);\n  }\n\n  add(other: IPoint) {\n    return new Vec(this.x + other.x, this.y + other.y);\n  }\n\n  subtract(other: IPoint) {\n    return new Vec(this.x - other.x, this.y - other.y);\n  }\n\n  multiply(scalar: number) {\n    return new Vec(this.x * scalar, this.y * scalar);\n  }\n\n  normalize(d = Math.hypot(this.x, this.y)) {\n    return new Vec(this.x / d, this.y / d);\n  }\n\n  /// Rotate the vector by 90 degrees. → becomes ↑\n  permutate() {\n    return new Vec(-this.y, this.x);\n  }\n\n  negative() {\n    return new Vec(-this.x, -this.y);\n  }\n\n  middle(other: IPoint) {\n    return new Vec((this.x + other.x) / 2, (this.y + other.y) / 2);\n  }\n\n  /// Rotate the vector around a center point.\n  rotate(center: IPoint, radius: number) {\n    const s = Math.sin(radius), c = Math.cos(radius),\n          px = this.x - center.x, py = this.y - center.y,\n          nx = px * c - py * s, ny = px * s + py * c;\n    return new Vec(nx + center.x, ny + center.y);\n  }\n\n  dot(other: IPoint) {\n    return this.x * other.x + this.y * other.y;\n  }\n\n  lerp(other: IPoint, t: number) {\n    return new Vec(this.x + (other.x - this.x) * t, this.y + (other.y - this.y) * t);\n  }\n\n  project(other: IPoint, c: number) {\n    return new Vec(this.x + other.x * c, this.y + other.y * c);\n  }\n}\n","const enum C {\n  timespan = 0.016667,\n  stiffness = 0.7,\n  damping = 0.5,\n  precision = 0.01,\n}\n\nexport class Spring {\n  value = -1\n  last = -1\n  target = -1\n  set(target: number): this {\n    this.target = target\n    if (this.value < 0) {\n      this.value = target\n      this.last = target\n    }\n    return this\n  }\n  update(dt?: number): number {\n    if (!dt) dt = C.timespan\n    if (this.value >= 0 && this.target >= 0 && this.last >= 0) {\n      let v = this.target\n      let delta = v - this.value\n      let velocity = (this.value - this.last) / dt\n      let spring = C.stiffness * delta\n      let damper = C.damping * velocity\n      let acceleration = spring - damper\n      let d = (velocity + acceleration) * dt\n      this.last = this.value\n      if (Math.abs(d) < C.precision && Math.abs(delta) < C.precision) {\n        this.value = this.target\n      } else {\n        this.value += d\n      }\n    }\n    return this.value\n  }\n}\n","//\n// Strokes are made up of a series of points, each point may have a pressure and a timestamp.\n// The algorithm's goal is to calculate a smooth outline of these points with known information.\n// The basic idea is each stroke is affected by 2 factors:\n//\n// - \"Thinning\": The stroke will be thinner if the pressure is lower and\n//               distance per interval between points become longer.\n//               Without timestamp we can assume the interval is constant.\n//\n// - \"Spreading\": The last several points will spread (be bigger) even after you lift the pen.\n//\n\nimport { clamp, IPoint, Vec } from \"./base\";\nimport { Spring } from \"./spring\";\n\n/// The data structure for raw input point, should be easy to convert from pointer events.\nexport class RawPoint implements IPoint {\n  /// @internal\n  constructor(\n    readonly x: number,\n    readonly y: number,\n    /// Pressure, range from 0 to 1. Use 0.5 for no-pressure cases.\n    readonly p: number,\n    /// Timestamp in milliseconds. Use 0 for no-timestamp cases.\n    readonly t: number,\n  ) { }\n\n  /// Construct a RawPoint from x, y, pressure and timestamp.\n  static of(x: number, y: number, pressure: number, timestamp: number) {\n    return new RawPoint(x, y, pressure, timestamp);\n  }\n\n  /// Construct a RawPoint from a PointerEvent.\n  /// The position is from clientX and clientY, which may not be the best choice\n  /// for draw boards supporting pinch and zoom. Use {@link RawPoint.of} instead.\n  static fromEvent(event: PointerEvent) {\n    // Some stylus devices may report zero pressure, treat as no-pressure.\n    return new RawPoint(event.clientX, event.clientY, clamp(event.pressure || 0.5, 0, 1), event.timeStamp);\n  }\n\n  /// @internal\n  static fromJSON(json: any) {\n    return new RawPoint(json.x, json.y, json.p, json.t);\n  }\n}\n\n/// The data structure for a point in a stroke, it has context information like\n/// its direction, distance to the previous point, and running length.\nexport class Point {\n  /// @internal\n  constructor(\n    readonly p: RawPoint,\n    /// Inverted direction of this point, equals to `previous - current`.\n    /// The first point's direction is the same as the second point.\n    readonly v: Vec,\n    /// Distance to the previous point, equals to `hypot(previous - current)`.\n    readonly d: number,\n    /// Running length from the first point to this point.\n    readonly l: number,\n  ) { }\n\n  static of(point: RawPoint, vector: Vec, distance: number, length: number) {\n    return new Point(point, vector, distance, length);\n  }\n\n  /// @internal\n  static fromJSON(json: any) {\n    return new Point(RawPoint.fromJSON(json.p), Vec.from(json.v), json.d, json.l);\n  }\n}\n\n// Constants which should not be exported as options.\nconst enum C {\n  // Skip points that are too close.\n  SkipDistance = 4,\n  // If the last |segment| > `TailDistance * size`, draw a thinner tail,\n  // otherwise draw an end cap.\n  TailDistance = 0.4,\n  // Math.PI + 0.0001 to prevent floating number issue when drawing the cap.\n  PI = 3.1416926535897933,\n  // Simulate pressure for mouse and trackpad.\n  PressureChangeSpeed = 0.7,\n  // Approximate ratio that multiplies `size` to draw a dot.\n  DotSize = 0.36,\n  // Minimal stroke width / 2.\n  MinRadius = 0.75,\n  // Spreading interval in milliseconds.\n  SpreadInterval = 350,\n  // Spreading amount per interval.\n  SpreadAmount = 0.15,\n}\n\n/// @internal Increase each point's pressure in the next period with a small amount.\nfunction pressureTillNow(p: Point, now: number) {\n  if (now - p.p.t > C.SpreadInterval) return Math.min(p.p.p + C.SpreadAmount, 1);\n  return Math.min(p.p.p + C.SpreadAmount * (now - p.p.t) / C.SpreadInterval, 1);\n}\n\n/// @internal Increase pressure for the next period with a small amount.\nfunction pressureTillNow2(p: number, t: number, now: number) {\n  if (now - t > C.SpreadInterval) return Math.min(p + C.SpreadAmount, 1);\n  return Math.min(p + C.SpreadAmount * (now - t) / C.SpreadInterval, 1);\n}\n\n/// The data structure for a stroke.\nexport class Stroke {\n  /// Indexes to split {@link Stroke.points} into curves. The first index is always `0`.\n  readonly segments: number[] = [0]\n  /// @internal See {@link Stroke.insert}.\n  readonly pending: { [from: number]: RawPoint[] } = { __proto__: null } as any\n\n  /// @internal\n  constructor(\n    /// The stroke's points. It grows on {@link Stroke.insert} and {@link Stroke.push}.\n    readonly points: Point[],\n    /// The stroke's length, equals to `points.at(-1).l`.\n    /// {@link Stroke.insert} and {@link Stroke.push} will update this value.\n    readonly length = points.length > 0 ? points[points.length - 1].l : 0,\n  ) { }\n\n  /// Create a stroke from raw points.\n  static of(raw: RawPoint[] = []): Stroke {\n    let stroke = new Stroke([], 0)\n    for (let p of raw) stroke._push(p)\n    stroke._updateSegments()\n    return stroke\n  }\n\n  /// Revive a stroke from `JSON.parse(JSON.stringify(oldStroke))`.\n  static fromJSON(json: any) {\n    let stroke = new Stroke(json.points.map(Point.fromJSON), json.length);\n    (stroke as { segments: number[] }).segments = json.segments;\n    (stroke as { pending: { [from: number]: RawPoint[] } }).pending = json.pending;\n    return stroke;\n  }\n\n  /// True when no points in the stroke.\n  get empty() { return this.length == 0 }\n\n  /// True when the stroke has only one point.\n  get dot() { return this.points.length == 1 }\n\n  /// Update the stroke with new points inserted from `from`.\n  /// The `from` can exceed the stroke's length, where the points will be\n  // pending until there be new points fill the gap.\n  insert(from: number, raw: RawPoint[]): this {\n    if (from == this.points.length) {\n      for (let p of raw) this._push(p)\n      from = this.points.length\n      if (raw = this.pending[from]) {\n        delete this.pending[from]\n        this.insert(from, raw)\n      }\n      // Recursively call {@link Stroke.insert} to flush pending points.\n      // Ensure a {@link Stroke._updateSegments} is called at the end of the recursion.\n      else {\n        this._updateSegments()\n      }\n    }\n    else if (from > this.points.length) {\n      this.pending[from] = raw\n    }\n    else {\n      throw new RangeError(`Position ${from} conflicts with existing points`)\n    }\n    return this\n  }\n\n  /// Update the stroke by pushing new points to the end.\n  push(raw: RawPoint): this {\n    this._push(raw)\n    this._updateSegments()\n    return this\n  }\n\n  /// @internal This method does not call `_updateSegments`.\n  _push(raw: RawPoint) {\n    let points = this.points\n    if (points.length > 0) {\n      let prev = points[points.length - 1]\n      let d = Math.hypot(raw.x - prev.p.x, raw.y - prev.p.y)\n      this._updateLength(d)\n      if (this.length - prev.l < C.SkipDistance) {\n        // Skip this point, but preserve its pressure.\n        (prev.p as { p: number }).p = Math.max(prev.p.p, raw.p)\n        return\n      }\n      points.push(Point.of(raw, Vec.from(raw).subtract(prev.p).normalize(), d, this.length))\n    } else {\n      points.push(Point.of(raw, Vec.of(0, 0), 0, 0))\n    }\n  }\n\n  /// Is the stroke still \"spreading\"?\n  isSpreading(now = performance.now()): boolean {\n    return this.points.length > 0 && now - this.points[this.points.length - 1].p.t < C.SpreadInterval\n  }\n\n  /// Compute the outline points of the segment starting at `from`.\n  /// Returns an empty array if `from` is not in {@link Stroke.segments}.\n  /// The `size` is the full width when pressure is 1.\n  outline(from: number, size: number, now = performance.now()): IPoint[] {\n    let end = this.segments.find(end => from < end)\n    let points = this.points.slice(from > 0 ? from - 1 : from, end)\n    if (points.length > 1) {\n      let leftPoints: Vec[] = [], rightPoints: Vec[] = [], length = points.length,\n          radius = size, prevPressure = points[0].p.p, drawEndCap = true,\n          prevTimestamp = 0, spring = new Spring()\n      // Draw a tail if the last segment is long enough.\n      if (end == null && length >= 2) {\n        let p2 = points[length - 2]\n        // The precisely comparing to 0.5 and 1.0 is probably a mouse event generated by chrome or firefox.\n        if ((p2.p.p == 0.5 || p2.p.p == 1) && p2.d > C.TailDistance * size) {\n          drawEndCap = false\n        }\n      }\n      // Simulate pressure and push points.\n      for (let i = 0; i < length; i++) {\n        let { p, v, d } = points[i]\n        // Fix first point's distance and direction (assume the same as the next point).\n        if (i == 0) {\n          d = 0\n          v = points[1].v\n        }\n        let sp = Math.min(1, d / size), rp = Math.min(1, 1 - sp),\n            pressure = Math.min(1, prevPressure + (rp - prevPressure) * (sp * C.PressureChangeSpeed)),\n            nextVector = (i < length - 1 ? points[i + 1] : points[i]).v,\n            nextDot = i < length - 1 ? v.dot(nextVector) : 1\n\n        pressure = spring.set(pressure).update(prevTimestamp && (p.t - prevTimestamp) / 1000)\n        // Tail case.\n        if (!drawEndCap) {\n          if (i == length - 1) pressure = 0.05\n          if (i == length - 2) pressure = Math.max(0.1, pressure - 0.2)\n          if (i == length - 3) pressure = Math.max(0.1, pressure - 0.1)\n        }\n\n        radius = clamp(size * 0.5 * pressureTillNow2(pressure, p.t, now), C.MinRadius, size / 2)\n\n        let offset = nextVector.lerp(v, nextDot).permutate().multiply(radius),\n            pl = Vec.from(p).subtract(offset),\n            pr = Vec.from(p).add(offset)\n\n        leftPoints.push(pl)\n        rightPoints.push(pr)\n\n        prevTimestamp = p.t\n        prevPressure = p.p\n      }\n      let startCap: Vec[] = [], firstPoint = rightPoints[0], endCap: Vec[] = []\n      for (let step = 1 / 13, t = 0; t <= 1; t += step) {\n        startCap.push(firstPoint.rotate(points[0].p, C.PI * t))\n      }\n      if (drawEndCap) {\n        let lastPoint = points[length - 1],\n            direction = lastPoint.v.negative().permutate(),\n            start = Vec.from(lastPoint.p).project(direction, radius)\n        for (let step = 1 / 13, t = 0; t < 1; t += step) {\n          endCap.push(start.rotate(lastPoint.p, C.PI * t))\n        }\n      }\n      return leftPoints.concat(endCap, rightPoints.reverse(), startCap)\n    }\n    // Dot case.\n    else if (points.length == 1) {\n      let p = points[0],\n          start = Vec.from(p.p).project(Vec.of(1, 0), size * C.DotSize * pressureTillNow(p, now)),\n          circle: Vec[] = []\n      for (let step = 1 / 13, t = 0; t <= 2; t += step) {\n        circle.push(start.rotate(p.p, C.PI * t))\n      }\n      return circle\n    }\n    else {\n      return []\n    }\n  }\n\n  /// Construct an SVG path string from raw points with basic smoothing.\n  stroke(points: IPoint[] = this.points.map(p => p.p)): string {\n    let n = points.length\n    if (n == 0) return \"\"\n    let prev = points[0], path = `M${prev.x.toFixed(2)},${prev.y.toFixed(2)}`\n    for (let i = 1; i < n; i++) {\n      let curr = points[i], middle = Vec.from(prev).middle(curr)\n      if (i == 1) path += `L${middle.x.toFixed(2)},${middle.y.toFixed(2)}`\n      else path += `Q${prev.x.toFixed(2)},${prev.y.toFixed(2)} ${middle.x.toFixed(2)},${middle.y.toFixed(2)}`\n      prev = curr\n    }\n    if (n > 1) path += `L${prev.x.toFixed(2)},${prev.y.toFixed(2)}`\n    return path\n  }\n\n  /// @internal Increase the running length.\n  _updateLength(d: number) {\n    (this as { length: number }).length += d\n  }\n\n  /// @internal Update {@link Stroke.segments} using current {@link Stroke.points}.\n  _updateSegments() {\n    let segments = this.segments, points = this.points, n = points.length\n    for (let i = segments[segments.length - 1] + 1; i < n; i++) {\n      if (points[i].v.dot(points[i - 1].v) < 0) {\n        segments.push(i)\n        i++\n      }\n    }\n  }\n}\n","import { RawPoint, Stroke } from './src/ink'\n\nlet $root = document.getElementById('app')!\nlet $svg = $root.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'svg'))\n\n$svg.setAttribute('fill-rule', 'nonzero')\n$svg.setAttribute('fill', 'currentColor')\n$svg.style.cssText = `display: block; width: 100%; height: 100%;\nfont-size: 0; touch-action: none; position: relative; contain: content;\noverflow: hidden; overscroll-behavior: none;`\n\nlet running = new Map<number, PointerEvent>()\n\n$svg.onpointerdown = (e) => {\n  let id = e.pointerId\n  if (running.has(id)) onCancel(id)\n  running.set(id, e)\n  e.preventDefault()\n  e.stopPropagation()\n  $svg.setPointerCapture(id)\n  // Ideally it should save $svg.getBoundingClientRect() for calculating the offset.\n  // In our demo case the offset is always 0.\n  onOpen(id, RawPoint.fromEvent(e))\n}\n\n$svg.onpointermove = (e) => {\n  let id = e.pointerId\n  e.preventDefault()\n  e.stopPropagation()\n  if (running.has(id)) {\n    let e0 = running.get(id)!\n    // Apple pencil's bug, it fires 2 identical events.\n    if (e0.clientX === e.clientX && e0.clientY === e.clientY) return\n    running.set(id, e)\n    if (!!e.getCoalescedEvents) for (let ev of e.getCoalescedEvents()) {\n      onUpdate(id, RawPoint.fromEvent(ev))\n    } else {\n      onUpdate(id, RawPoint.fromEvent(e))\n    }\n  }\n}\n\n$svg.onpointerup = $svg.onpointerout = (e) => {\n  let id = e.pointerId\n  e.preventDefault()\n  e.stopPropagation()\n  if (running.has(id)) {\n    if (!!e.getPredictedEvents) {\n      // Use last point's predict result instead of this pointerup event.\n      let ev = running.get(id)!.getPredictedEvents()[0]\n      if (ev) onUpdate(id, RawPoint.fromEvent(ev))\n    }\n    onClose(id)\n    running.delete(id)\n  }\n}\n\n$svg.onpointercancel = (e) => {\n  let id = e.pointerId\n  e.preventDefault()\n  e.stopPropagation()\n  if (running.has(id)) {\n    onCancel(id)\n    running.delete(id)\n  }\n}\n\n$svg.ontouchstart = $svg.ontouchmove = $svg.ontouchend = $svg.ontouchcancel = (e) => {\n  e.preventDefault()\n  e.stopPropagation()\n}\n\nlet strokes: { [id: number]: [Stroke, SVGPathElement] } = {}\nlet dirty: { [id: number]: true } = {}\n\nlet onOpen = (id: number, p: RawPoint) => {\n  let stroke = Stroke.of([p])\n  let $path = $svg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'path'))\n  $path.style.pointerEvents = 'none'\n  strokes[id] = [stroke, $path]\n  dirty[id] = true\n  render()\n}\n\nlet onUpdate = (id: number, p: RawPoint) => {\n  if (strokes[id]) {\n    strokes[id][0].push(p)\n    dirty[id] = true\n    render()\n  }\n}\n\nlet onCancel = (id: number) => {\n  if (strokes[id]) {\n    strokes[id][1].remove()\n    delete strokes[id]\n    delete dirty[id]\n  }\n}\n\nlet onClose = (id: number) => {\n  if (strokes[id]) {\n    let [stroke, $path] = strokes[id]\n    if (stroke.empty) {\n      $path.remove()\n    }\n    render()\n    delete dirty[id]\n    requestAnimation()\n  }\n}\n\n// Full width of the stroke if pressure is 1.\nlet size = 12\n\n// This happens synchronously, without even a microtask.\nlet render = () => {\n  for (let id in dirty) {\n    if (strokes[id]) {\n      let [stroke, $path] = strokes[id], d = ''\n      for (let index of stroke.segments) {\n        let outline = stroke.outline(index, size)\n        d += stroke.stroke(outline)\n      }\n      $path.setAttribute('d', d)\n    }\n    delete dirty[id]\n  }\n}\n\nlet animateId = 0\n\nlet requestAnimation = () => {\n  cancelAnimationFrame(animateId)\n  animateId = requestAnimationFrame(updateAnimation)\n}\n\nlet updateAnimation = () => {\n  render()\n  let schedule = false\n  for (let id in strokes) {\n    if (strokes[id][0].isSpreading()) {\n      dirty[id] = true\n      schedule = true\n    } else {\n      delete strokes[id]\n    }\n  }\n  if (schedule) requestAnimation()\n}\n"],"names":["clamp","value","min","max","Vec","x","y","vec","other","scalar","d","center","radius","s","c","px","py","nx","ny","t","Spring","target","dt","delta","velocity","spring","damper","acceleration","RawPoint","p","pressure","timestamp","event","json","Point","v","l","point","vector","distance","length","pressureTillNow","now","pressureTillNow2","Stroke","points","raw","stroke","from","prev","size","end","leftPoints","rightPoints","prevPressure","drawEndCap","prevTimestamp","p2","i","sp","rp","nextVector","nextDot","offset","pl","pr","startCap","firstPoint","endCap","step","lastPoint","direction","start","circle","n","path","curr","middle","segments","$root","$svg","running","e","id","onOpen","e0","ev","onUpdate","onClose","onCancel","strokes","dirty","$path","render","requestAnimation","index","outline","animateId","updateAnimation","schedule"],"mappings":"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"}
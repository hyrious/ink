{"version":3,"file":"index-DWrVlt6I.js","sources":["../../src/vec.ts","../../src/ink.ts","../../main.ts"],"sourcesContent":["/// 2D vector\nexport interface Vec {\n  readonly x: number\n  readonly y: number\n}\n\nexport const norm = ({ x, y }: Vec, d = Math.hypot(x, y)): Vec => ({ x: x / d, y: y / d })\nexport const add = (a: Vec, b: Vec): Vec => ({ x: a.x + b.x, y: a.y + b.y })\nexport const sub = (a: Vec, b: Vec): Vec => ({ x: a.x - b.x, y: a.y - b.y })\nexport const mul = (a: Vec, n: number): Vec => ({ x: a.x * n, y: a.y * n })\nexport const per = ({ x, y }: Vec): Vec => ({ x: y, y: -x })\nexport const neg = ({ x, y }: Vec): Vec => ({ x: -x, y: -y })\nexport const mid = (a: Vec, b: Vec): Vec => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 })\n\n/// Rotate point `(x, y)` around point `C` in raidus `r`.\nexport const rot = ({ x, y }: Vec, C: Vec, r: number) => {\n  const s = Math.sin(r), c = Math.cos(r),\n        px = x - C.x, py = y - C.y,\n        nx = px * c - py * s,\n        ny = px * s + py * c\n  return { x: nx + C.x, y: ny + C.y }\n}\n\nexport const dot = (a: Vec, b: Vec) => a.x * b.x + a.y * b.y\nexport const lerp = (a: Vec, b: Vec, t: number) => add(a, mul(sub(b, a), t))\nexport const proj = (a: Vec, b: Vec, c: number) => add(a, mul(b, c))\n\nexport const copy = (a: Vec, b: Vec) => {\n  (a as { x: number }).x = b.x;\n  (a as { y: number }).y = b.y\n  return a\n}\n","import { add, dot, lerp, mul, neg, norm, per, proj, rot, sub, type Vec } from './vec'\n\nexport type { Vec }\n\n// Internal constants, I don't plan to expose them as options.\nconst enum C {\n  // SAI-like input smoothing strategy: keep a queue of points\n  // and get middle of them. The queue size is `Smoothing + 1`.\n  Smoothing = 1,\n  // Skip points that are too close.\n  SkipDistance = 4,\n  // If |segment| < `MinDistance` and is sharp corner, split here\n  // and skip next `CoolingDown` points for performance.\n  // `CoolingDown` must > 0.\n  MinDistance = 1000, CoolingDown = 1,\n  // If the last |segment| > `TailDistance * size`, draw a thinner tail,\n  // otherwise draw an end cap.\n  TailDistance = 0.314,\n  // Math.PI + 0.0001 to prevent floating number issue when drawing the cap.\n  PI = 3.1416926535897933,\n  // Simulate pressure for mouse and trackpad.\n  PressureChangeSpeed = 0.3,\n  // Approximate ratio that multiplies `size` to draw a dot.\n  DotSize = 0.36,\n  // Minimal stroke width / 2.\n  MinRadius = 0.75,\n  // Zoom speed by mouse wheel.\n  Scale = 0.035,\n  // Prevent zooming too fast.\n  MinScale = -40, ScaleRate = 0.02,\n}\n\nexport interface RawPoint extends Vec {\n  readonly r: number\n}\n\n/// The data structure for a point with its context information.\nclass Point {\n  /// @internal\n  constructor(\n    /// The point's position.\n    readonly p: Vec,\n    /// Radius or pressure.\n    readonly r: number,\n    /// The inverted direction of this point, equals to `previous - current`.\n    /// The first point's `v` is a dummy value.\n    readonly v: Vec,\n    /// Distance to previous point, equals to `hypot(previous - current)`.\n    readonly d: number,\n    /// Running length, the last point's `l` is the stroke's approximate length.\n    readonly l: number,\n  ) {}\n\n  /// @internal\n  toJSON(): any {\n    return [this.p.x, this.p.y, this.r]\n  }\n\n  /// @internal Returns a shallow copy of this point, with raidus changed.\n  dup(r = this.r): Point {\n    return new Point(this.p, r, this.v, this.d, this.l)\n  }\n}\n\n/// The data structure for a single stroke, which contains many points.\nexport class Stroke {\n  /// Indexes to split `points` into curves. The first index is always `0`.\n  readonly sections: number[] = [0]\n  /// @internal See `insert()`.\n  readonly pending: { [from: number]: RawPoint[] } = { __proto__: null } as any\n  /// @internal See `updateCurr()`.\n  readonly queue: Vec[] = []\n\n  /// @internal\n  constructor(\n    /// The stroke's points. It is guaranteed that this is a grow-only immutable array.\n    readonly points: Point[],\n    /// The stroke's length, equals to `points.at(-1).l`.\n    /// `insert()` and `push()` will update this value.\n    readonly length = points.length > 0 ? points[points.length - 1].l : 0,\n  ) {\n    this.updateSections()\n  }\n\n  /// True when `points` is empty.\n  get empty(): boolean { return this.points.length == 0 }\n\n  /// True when `points` contains exactly one element.\n  get dot(): boolean { return this.points.length == 1 }\n\n  /// Update the stroke with new points inserted from `from`.\n  /// `from` can exceed `points.length`, where the points will be\n  /// pending unless there are new points fill in the hole.\n  insert(from: number, raw: RawPoint[]): void {\n    if (from == this.points.length) {\n      raw.forEach(p => this.push(p, true))\n      from = this.points.length\n      if ((raw = this.pending[from])) {\n        delete this.pending[from]\n        this.insert(from, raw)\n      }\n      // Recursively call `insert()` to flush pending points.\n      // Ensure `updateSections()` is called at the end or recursion.\n      else {\n        this.updateSections()\n      }\n    }\n    else if (from > this.points.length) {\n      if (__DEV__ && this.pending[from])\n        console.warn(`Override pending points from ${from}`)\n      this.pending[from] = raw\n    }\n    else {\n      throw new RangeError(`Position ${from} conflicts with existing points`)\n    }\n  }\n\n  /// Update the stroke with new point appended to the end of `points`.\n  /// If `skip_sections` is `true`, it will not update `sections`.\n  push(p: RawPoint, skip_sections = false): void {\n    let { points } = this\n    if (points.length > 0) {\n      let curr: RawPoint, prev_ = points[points.length-1]\n      // @ts-ignore No smoothing, get the raw input.\n      if (C.Smoothing == 0) curr = p\n      // @ts-ignore Level-1 smoothing, get the center of each segment.\n      else if (C.Smoothing == 1)\n        curr = { x: (p.x + prev_.p.x) / 2, y: (p.y + prev_.p.y) / 2, r: p.r }\n      // Level-N smoothing\n      else {\n        curr = this.updateCurr(p, C.Smoothing + 1)\n      }\n      let prev = prev_.p, d = Math.hypot(curr.x - prev.x, curr.y - prev.y);\n      this.updateLength(d)\n      if (this.length - prev_.l < C.SkipDistance) {\n        // Skip this point, but preserve its pressure.\n        (prev_ as { r: number }).r = Math.max(prev_.r, curr.r)\n        return\n      }\n      points.push(new Point(curr, curr.r, norm(sub(prev, curr)), d, this.length))\n      if (!skip_sections) this.updateSections()\n    }\n    else {\n      points.push(new Point(p, p.r, { x: 1, y: 1 }, 0, 0))\n    }\n  }\n\n  /// Compute the outline points of the section starting at `from`.\n  /// Returns an empty array if `from` is not zero and not in `sections`.\n  /// `size` is the full width when pressure is 1.\n  outline(from: number, size: number): Vec[] {\n    let end = this.sections.find(end => from < end)\n    // Get one more point at head to connect curves.\n    let points = this.points.slice(from > 0 ? from - 1 : from, end)\n    if (points.length > 1) {\n      let leftPoints: Vec[] = [], rightPoints: Vec[] = [], len = points.length,\n          radius = size, prevPressure = points[0].r, drawEndCap = true\n      // If `end` is `undefined`, this is the final section. Draw a thinner tail when possible.\n      // The precisely comparing to `0.5` is probably a mouse event (i.e. no real pressure).\n      if (end == null && points[len - 1].r == 0.5 && points[len - 1].d > C.TailDistance * size) {\n        if (len - 1 >= 0) points[len - 1] = points[len - 1].dup(Math.max(0.1, points[len - 1].r - 0.4))\n        if (len - 2 >= 0) points[len - 2] = points[len - 2].dup(Math.max(0.1, points[len - 2].r - 0.2))\n        drawEndCap = false\n      }\n      // Simulate pressure and push left/right points.\n      for (let i = 0; i < len; i++) {\n        let { p, r, v, d } = points[i]\n        // Fix first point's distance and direction (assume the same as the next point).\n        if (i == 0) {\n          d = 0\n          if (i < len - 1) v = points[i + 1].v\n        }\n        let sp = Math.min(1, d / size), rp = Math.min(1, 1 - sp),\n            pressure = Math.min(1, prevPressure + (rp - prevPressure) * (sp * C.PressureChangeSpeed)),\n            nextVector = (i < len - 1 ?  points[i + 1] : points[i]).v,\n            nextDot = i < len - 1 ? dot(v, nextVector) : 1\n\n        radius = Math.max(size * (0.5 * pressure), C.MinRadius)\n\n        let offset = mul(per(lerp(nextVector, v, nextDot)), radius)\n        let pl = sub(p, offset); leftPoints.push(pl)\n        let pr = add(p, offset); rightPoints.push(pr)\n\n        prevPressure = r\n      }\n      let startCap: Vec[] = [], endCap: Vec[] = []\n      for (let step = 1 / 13, t = step; t <= 1; t += step) {\n        startCap.push(rot(rightPoints[0], points[0].p, C.PI * t))\n      }\n      if (drawEndCap) {\n        let lastPoint = points[len - 1],\n            direction = per(neg(lastPoint.v)),\n            start = proj(lastPoint.p, direction, radius)\n        for (let step = 1 / 13, t = step; t < 1; t += step) {\n          endCap.push(rot(start, lastPoint.p, C.PI * t))\n        }\n      }\n      return leftPoints.concat(endCap, rightPoints.reverse(), startCap)\n    }\n    // Dot case.\n    else if (points.length == 1) {\n      let lastPoint = points[0],\n          direction = per(neg(lastPoint.v)),\n          start = proj(lastPoint.p, direction, size * C.DotSize * lastPoint.r),\n          circle: Vec[] = []\n      for (let step = 1 / 13, t = 0; t <= 2; t += step) {\n        circle.push(rot(start, lastPoint.p, C.PI * t))\n      }\n      return circle\n    }\n    else {\n      return []\n    }\n  }\n\n  /// @internal Increment `length`.\n  updateLength(d: number) {\n    (this as { length: number }).length += d\n  }\n\n  /// @internal Update `sections` incrementally using current `points`.\n  updateSections() {\n    let { sections } = this;\n    // The first 2 points share the same vector, skip them.\n    for (let i = sections.length > 1 ? (sections[sections.length-1] + C.CoolingDown) : 2,\n             len = this.points.length; i < len; i++) {\n      if (this.points[i].d < C.MinDistance &&\n          dot(this.points[i].v, this.points[i-1].v) < 0) {\n        sections.push(i)\n        i += C.CoolingDown\n      }\n    }\n  }\n\n  /// @internal Perform smoothing.\n  updateCurr(p: RawPoint, n: number): RawPoint {\n    this.queue.push(p)\n    while (this.queue.length > n)\n      this.queue.shift()\n    let x = 0, y = 0\n    for (let q of this.queue) {\n      x += q.x\n      y += q.y\n    }\n    n = this.queue.length\n    return { x: x / n, y: y / n, r: p.r }\n  }\n\n  /// Convert this stroke to a JSON-serializable object.\n  toJSON(): any {\n    return this.points.map(p => p.toJSON())\n  }\n\n  /// De-serialize a stroke from its JSON representation.\n  static fromJSON(json: any): Stroke {\n    if (!json || !Array.isArray(json))\n      throw new RangeError(\"Invalid JSON representation for Stroke\")\n    return Stroke.create(json.map(a => ({ x: a[0], y: a[1], r: a[2] })))\n  }\n\n  /// Create a new stroke from raw input.\n  static create(raw: RawPoint[] = []): Stroke {\n    let points: Point[] = [], last_length = 0\n    if (raw.length > 0) {\n      let prev = raw[0], length = 0\n      points.push(new Point(prev, prev.r, { x: 1, y: 1 }, 0, 0))\n      for (let i = 1; i < raw.length; i++) {\n        let curr = raw[i], d = Math.hypot(curr.x - prev.x, curr.y - prev.y)\n        length += d\n        if (length - last_length < C.SkipDistance) {\n          // Skip this point and keep pressure.\n          (points[points.length - 1] as { r: number }).r = curr.r\n          continue;\n        }\n        points.push(new Point(curr, curr.r, norm(sub(prev, curr)), d, length))\n        prev = curr\n        last_length = length\n      }\n      // Even if the last points not get pushed, their distance is added.\n      last_length = length\n    }\n    return new Stroke(points, last_length)\n  }\n}\n\ntype Params<Fn = any> = Fn extends (...args: any) => any ? Parameters<Fn> : never\n\n/// Handles named events.\nclass Observable<EventMap = any> {\n  /// @internal\n  _observers = new Map<any, Set<any>>()\n\n  on<E extends keyof EventMap>(event: E, fn: EventMap[E]): () => void {\n    let set = this._observers.get(event)\n    if (set === undefined) {\n      this._observers.set(event, set = new Set())\n    }\n    set.add(fn)\n    return this.off.bind(this, event, fn)\n  }\n\n  off<E extends keyof EventMap>(event: E, fn: EventMap[E]): void {\n    let set = this._observers.get(event)\n    if (set !== undefined) {\n      set.delete(fn)\n      if (set.size == 0) this._observers.delete(event)\n    }\n  }\n\n  emit<E extends keyof EventMap>(event: E, ...args: Params<EventMap[E]>): void {\n    let set = this._observers.get(event)\n    if (set) set.forEach(f => this._invoke(f, args))\n  }\n\n  /// @internal\n  _invoke(f: any, args: any) {\n    try {\n      f(...args)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n\n  dispose() {\n    this._observers.clear()\n  }\n}\n\ninterface Transform {\n  readonly x: number\n  readonly y: number\n  readonly scale: number\n}\n\nexport interface InputEventMap {\n  'open': (pointerId: number, point: RawPoint) => void\n  'update': (pointerId: number, point: RawPoint) => void\n  'cancel': (pointerId: number) => void\n  'close': (pointerId: number) => void\n  'pinch': (transform: Transform) => void\n}\n\nexport interface InputConfig {\n  /// The element to bind events like `pointermove`.\n  dom?: HTMLElement | SVGElement\n  /// Whether to stop reporting events, default is `false`.\n  paused?: boolean\n  /// Whether to handle pinch zoom gestures (multi-touch), default is `true`.\n  gesture?: boolean\n  /// Whether to use `poinetrEvent.pressure`, default is `true`.\n  /// If `false`, it will always use `0.5` as the pressure number.\n  /// Or you can set it as a custom number ranges in (0, 1].\n  pressure?: boolean | number\n  /// Whether to treat mouse wheel events on Windows as scrolling, default is `true`.\n  /// If `false`, it will perform zooming on mouse wheel events.\n  windowsScroll?: boolean\n}\n\ninterface PinchDesc { x: number, y: number, area: number }\n\nclass Pinch {\n  readonly points = new Map<number, PointerEvent>()\n  // This pinch runs from (x0, y0, 1) to (x1, y1, scale).\n  x0 = 0; y0 = 0; x1 = 0; y1 = 0; scale = 1\n  ox = 0; oy = 0; rate = 1\n\n  _desc(): PinchDesc {\n    let x = 0, y = 0, area = 0\n    for (let ev of this.points.values()) {\n      x += ev.clientX\n      y += ev.clientY\n    }\n    x /= this.points.size\n    y /= this.points.size\n    for (let ev of this.points.values()) {\n      area += Math.hypot(ev.clientX - x, ev.clientY - y)\n    }\n    if (area == 0) area = 1\n    return { x, y, area }\n  }\n\n  _init(desc: PinchDesc) {\n    this.ox = this.oy = 0\n    this.rate = 1 / desc.area\n    this.x1 = this.x0 = desc.x\n    this.y1 = this.y0 = desc.y\n    this.scale = 1\n  }\n\n  _sync(desc: PinchDesc) {\n    this.ox = this.x1 - desc.x\n    this.oy = this.y1 - desc.y\n    this.rate = this.scale / desc.area\n  }\n\n  _update(desc: PinchDesc) {\n    this.x1 = desc.x + this.ox\n    this.y1 = desc.y + this.oy\n    this.scale = desc.area * this.rate\n  }\n\n  constructor(readonly input: Input) {}\n\n  get empty(): boolean { return this.points.size == 0 }\n\n  has(id: number): boolean { return this.points.has(id) }\n\n  add(ev: PointerEvent) {\n    this.points.set(ev.pointerId, ev)\n    let desc = this._desc()\n    if (this.points.size == 1) {\n      this._init(desc)\n    } else {\n      this._sync(desc)\n      this._update(desc)\n    }\n  }\n\n  move(ev: PointerEvent) {\n    this.points.set(ev.pointerId, ev)\n    this._update(this._desc())\n    this.input.emit('pinch', { x: this.x0 - this.x1, y: this.y0 - this.y1, scale: this.scale })\n  }\n\n  delete(id: number) {\n    this.points.delete(id)\n    if (this.points.size > 0) {\n      let desc = this._desc()\n      this._sync(desc)\n      this._update(desc)\n    }\n  }\n}\n\nconst nav = typeof navigator != 'undefined' ? navigator : { platform: \"\" }\nconst browser = {\n  mac: /Mac/.test(nav.platform),\n  windows: /Win/.test(nav.platform),\n}\n\n/// Helper class to handle pointer events.\n/// To disable intrinsic user agent touch behaviors (such as panning or zooming),\n/// add style `touch-action: none` to the target element.\nexport class Input extends Observable<InputEventMap> {\n  /// @internal pointerId => pointerEvent\n  readonly _map = new Map<number, PointerEvent>()\n  /// @internal\n  _dom?: HTMLElement | SVGElement\n  /// @internal\n  _unlistenDOM?: () => void\n  /// @internal It will be set in pointerdown, so never be undefined.\n  _rect: DOMRect\n\n  /// @internal\n  constructor(\n    /// Whether to stop reporting events, default is `false`.\n    public paused = false,\n    /// Whether to handle pinch zoom gestures (multi-touch), default is `true`.\n    /// - `true`: Multi-touch events will fire a `cancel` stroke event and `pinch` events follows.\n    /// - `false`: Treat each `pointerId` as a single stroke.\n    /// - `\"strict\"`: Same as `true`, but only when `pointerType` is `\"touch\"`.\n    public gesture: boolean | \"strict\" = true,\n    /// Whether to use the `pressure` property from pointer events, default is `true`.\n    /// - `true`: Use pressure from pointer events.\n    /// - `false`: Same as `0.5`.\n    /// - number range from 0 (exclusive) to 1 (inclusive): Use this value as pressure.\n    public pressure: boolean | number = true,\n    /// Whether to treat wheel event as scrolling on Windows, default is `true`.\n    /// If `false`, wheel events will be treated as zooming.\n    public windowsScroll: boolean = true,\n  ) {\n    super()\n  }\n\n  /// The element to bind events like `pointermove`.\n  get dom(): HTMLElement | SVGElement | undefined { return this._dom }\n  set dom(v: HTMLElement | SVGElement | undefined) {\n    if (this._dom == v) return;\n    this._dom = v\n    this._listen(this._dom, {\n      pointerdown: this._onpointerdown,\n      pointermove: this._onpointermove,\n      pointerup: this._onpointerup,\n      pointerout: this._onpointerup,\n      pointercancel: this._onpointercancel,\n      wheel: this._onwheel,\n    })\n    if (this._dom) this._rect = this._dom.getBoundingClientRect()\n  }\n\n  pause(): void { this.paused = true }\n  resume(): void { this.paused = false }\n\n  /// @internal\n  _listen(element: HTMLElement | SVGElement | undefined, eventMap: { [name: string]: (...args: any) => any }) {\n    if (this._unlistenDOM) {\n      this._unlistenDOM()\n      this._unlistenDOM = void 0\n    }\n    if (element) {\n      for (let name in eventMap) element.addEventListener(name, eventMap[name])\n      this._unlistenDOM = () => { for (let name in eventMap) element.removeEventListener(name, eventMap[name]) }\n    }\n  }\n\n  /// @internal The '<=' is intended for (0, 1] check.\n  _clamp(val: number, min: number, max: number): number {\n    return val <= min ? min : val > max ? max : val\n  }\n\n  /// @internal\n  _mapPressure(real: number): number {\n    return this.pressure === true ? real : this._clamp(this.pressure || 0.5, 0, 1)\n  }\n\n  /// @internal\n  _mapGesture(ev: PointerEvent): boolean {\n    return this.gesture === true || (this.gesture && ev.pointerType == 'touch')\n  }\n\n  /// @internal\n  _pinch = new Pinch(this)\n\n  /// @internal\n  _onpointerdown = (ev: PointerEvent) => {\n    if (this.paused) return;\n    let id = ev.pointerId\n    if (this._map.has(id)) this.emit('cancel', id);\n    this._map.set(id, ev)\n    ev.preventDefault()\n    ev.stopPropagation()\n    this._dom!.setPointerCapture(id)\n    if (this._mapGesture(ev) && this._map.size > 1) {\n      // Emit 'cancel' to all other strokes.\n      this._map.forEach((ev2, id2) => {\n        if (!this._pinch.has(id2)) {\n          if (id != id2) this.emit('cancel', id2)\n          this._pinch.add(ev2)\n        }\n      })\n    } else {\n      let rect = this._rect = this._dom!.getBoundingClientRect()\n      this.emit('open', id, { x: ev.clientX - rect.left, y: ev.clientY - rect.top, r: this._mapPressure(ev.pressure) })\n    }\n  }\n\n  /// @internal\n  _onpointermove = (ev: PointerEvent) => {\n    if (this.paused) return;\n    let id = ev.pointerId\n    ev.preventDefault()\n    ev.stopPropagation()\n    if (this._map.has(id)) {\n      let ev0 = this._map.get(id)!\n      // Apple pencil's bug, it fires 2 identical events.\n      if (ev0.clientX == ev.clientX && ev0.clientY == ev.clientY) return;\n      this._map.set(id, ev)\n      // Stroke mode.\n      if (this._pinch.empty) {\n        // Firefox's bug, it gives 0 to pointer events generated by mouse.\n        let pressure: number | undefined\n        if (ev.pointerType == 'mouse' && ev.pressure == 0) pressure = this._mapPressure(0.5);\n        let { left, top } = this._rect\n        // @ts-ignore Get the most precise pointer events.\n        if (ev.getCoalescedEvents) for (let ev1 of ev.getCoalescedEvents()) {\n          this.emit('update', id, { x: ev1.clientX - left, y: ev1.clientY - top, r: pressure ?? this._mapPressure(ev.pressure) })\n        } else {\n          this.emit('update', id, { x: ev.clientX - left, y: ev.clientY - top, r: pressure ?? this._mapPressure(ev.pressure) })\n        }\n      }\n      // Pinch mode.\n      else {\n        this._pinch.move(ev)\n      }\n    }\n  }\n\n  /// @internal\n  _onpointerup = (ev: PointerEvent) => {\n    if (this.paused) return;\n    let id = ev.pointerId\n    ev.preventDefault()\n    ev.stopPropagation()\n    if (this._map.has(id)) {\n      // Stroke mode.\n      if (this._pinch.empty) {\n        // @ts-ignore Safari does not have this method.\n        if (ev.getPredictedEvents) {\n          let pred = this._map.get(id)?.getPredictedEvents()[0]\n          let rect = this._rect\n          if (pred) this.emit('update', id, {\n            x: Math.round(pred.clientX - rect.left),\n            y: Math.round(pred.clientY - rect.top),\n            r: this._mapPressure(pred.pressure),\n          })\n        }\n        this.emit('close', id)\n      }\n      // Pinch mode.\n      else {\n        this._pinch.delete(id)\n      }\n      this._map.delete(id)\n    }\n  }\n\n  /// @internal\n  _onpointercancel = (ev: PointerEvent) => {\n    if (this.paused) return;\n    let id = ev.pointerId\n    ev.preventDefault()\n    ev.stopPropagation()\n    this._map.delete(id)\n    // Stroke mode.\n    if (this._pinch.empty) {\n      this.emit('cancel', id)\n    }\n    // Pinch mode.\n    else {\n      this._pinch.delete(ev.pointerId)\n    }\n  }\n\n  /// @internal\n  _onwheel = (ev: WheelEvent) => {\n    ev.preventDefault()\n    ev.stopPropagation()\n    let { deltaX, deltaY } = ev\n    let scale = Math.hypot(deltaX, deltaY)\n    let x = 0, y = 0\n    if (browser.windows) scale = -scale;\n    if (deltaX + deltaY < 0) scale = -scale;\n    // macOS zoom by trackpad\n    if (browser.mac && ev.ctrlKey) scale = -scale * 0.5;\n    // macOS scroll by trackpad\n    else if (browser.mac && ((ev as any).wheelDelta % 120 != 0 || ev.movementX != 0 || ev.deltaX != 0)\n          // Windows updown scroll by mouse\n          || this.windowsScroll && browser.windows && !ev.ctrlKey) {\n      x = -deltaX\n      y = -deltaY\n      scale = 0\n    }\n    // Normal zoom by scroll.\n    else scale *= C.Scale\n    scale = 1 + Math.max(scale, C.MinScale) * C.ScaleRate\n    this.emit('pinch', { x, y, scale })\n  }\n\n  /// Remove all subscribers and DOM listeners.\n  override dispose(): void {\n    if (this._unlistenDOM) {\n      this._unlistenDOM()\n      this._unlistenDOM = void 0\n    }\n    super.dispose()\n  }\n\n  /// Create a new input handler.\n  static create(config: InputConfig = {}) {\n    let input = new Input(config.paused, config.gesture, config.pressure, config.windowsScroll)\n    input.dom = config.dom\n    return input\n  }\n}\n","import { Stroke, Input, type Vec } from './src/ink'\n\nlet $root = document.getElementById('app')!\nlet $svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\nlet $g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\nlet $settings = {\n  size: document.getElementById('stroke-size') as HTMLInputElement,\n  clear: document.getElementById('clear') as HTMLButtonElement,\n  undo: document.getElementById('undo') as HTMLButtonElement,\n  redo: document.getElementById('redo') as HTMLButtonElement,\n  outline: document.getElementById('outline') as HTMLInputElement,\n  data: document.getElementById('data') as HTMLElement,\n}\n\nlet renderingMs = 0\nlet total = 0\nfunction updateData(stroke: Stroke) {\n  try {\n    let bytes = JSON.stringify(stroke.toJSON()).length\n    total += bytes\n    $settings.data.textContent = `${renderingMs.toFixed(1)}ms, ${prettyBytes(bytes)} (Total: ${prettyBytes(total)})`\n  } catch (err) {\n    console.error(err)\n  }\n}\n\nfunction prettyBytes(n: number) {\n  return n < 1024 ? n + ' B' : (n / 1024).toFixed(1) + ' kB'\n}\n\nlet undoStack = {\n  index: 0,\n  // Suppose we have committed 2 strokes:\n  //\n  //   stack = [delete_stroke_1, delete_stroke_2]\n  //                                            ^ index = 2\n  // Now call `undo()`, what happens is index--:\n  //\n  //   stack = [delete_stroke_1, restore_stroke_2]\n  //                           ^ index = 1\n  //                             ^^^^^^^^^^^^^^^^ replace the undo() with redo()\n  stack: [],\n  get undoable(): boolean { return this.index > 0 },\n  get redoable(): boolean { return this.index < this.stack.length },\n  commit(undo: () => void, redo: () => void) {\n    this.stack[this.index] = { undo, redo }\n    this.index += 1\n    // Max 20 steps.\n    while (this.stack.length > 20) {\n      this.stack.shift()\n      this.index -= 1\n    }\n    // Clear all redos.\n    this.stack.length = this.index\n    this.update()\n  },\n  undo() {\n    if (this.undoable) {\n      this.index -= 1\n      this.stack[this.index].undo()\n      this.update()\n    }\n  },\n  redo() {\n    if (this.redoable) {\n      this.stack[this.index].redo()\n      this.index += 1\n      this.update()\n    }\n  },\n  update() {\n    $settings.undo.disabled = !this.undoable\n    $settings.redo.disabled = !this.redoable\n  },\n}\n\n$svg.append($g)\n$root.append($svg)\n\n$settings.clear.onclick = () => {\n  let current = Array.from($g.children)\n  $g.textContent = ''\n  undoStack.commit(\n    () => $g.append(...current),\n    () => $g.textContent = '',\n  )\n}\n\n$settings.undo.onclick = () => undoStack.undo()\n$settings.redo.onclick = () => undoStack.redo()\n\n$g.setAttribute('fill', 'currentColor')\n$settings.outline.oninput = () => {\n  let outline = $settings.outline.checked\n  if (outline) {\n    $g.setAttribute('fill', 'none')\n    $g.setAttribute('stroke', 'currentColor')\n    $g.setAttribute('stroke-width', '1')\n  } else {\n    $g.setAttribute('fill', 'currentColor')\n  }\n}\n\n\n$svg.setAttribute('fill-rule', 'nonzero')\n$svg.style.cssText = 'display: block; width: 100%; height: 100%; font-size: 0; touch-action: none; position: relative; contain: content'\n\nlet scheduled = false\nlet strokes = { __proto__: null } as { [id: number]: [s: Stroke, p: SVGPathElement] }\nlet dirty = { __proto__: null } as { [id: number]: true }\nlet input = Input.create({ dom: $svg })\n\n// const clamp = (val: number, min: number, max: number) => {\n//   return val < min ? min : val > max ? max : val\n// }\n// let transform = { x: 0, y: 0, scale: 1 }\n// input.on('pinch', ({ x, y, scale }) => {\n//   console.log('pinch', x, y, scale)\n//   transform.x += x\n//   transform.y += y\n//   transform.scale *= scale\n//   // Limit viewport.\n//   transform.x = clamp(transform.x, -400, 400)\n//   transform.y = clamp(transform.y, -300, 300)\n//   transform.scale = clamp(transform.scale, 0.125, 4)\n//   // Update.\n//   $g.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`\n// })\n\ninput.on('open', (id, raw) => {\n  let stroke = Stroke.create([raw])\n  let $path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n  $path.style.pointerEvents = 'none'\n  strokes[id] = [stroke, $path]\n  dirty[id] = true\n  $g.append($path)\n  if (scheduled) return;\n  scheduled = true\n  queueMicrotask(render)\n})\n\ninput.on('update', (id, raw) => {\n  if (strokes[id]) {\n    let [stroke] = strokes[id]\n    stroke.push(raw)\n    dirty[id] = true\n    if (scheduled) return;\n    scheduled = true\n    queueMicrotask(render)\n  }\n})\n\ninput.on('cancel', (id) => {\n  if (strokes[id]) {\n    strokes[id][1].remove()\n    delete strokes[id]\n  }\n})\n\ninput.on('close', (id) => {\n  if (strokes[id]) {\n    let [stroke, $path] = strokes[id]\n    let commit = true\n    if (stroke.empty) {\n      $path.remove()\n      commit = false\n    }\n    updateData(stroke)\n    console.log(stroke)\n    scheduled = true\n    render()\n    delete strokes[id]\n    if (commit) undoStack.commit(\n      () => $path.remove(),\n      // The z-index is not correct, but this demo does not care about it.\n      () => $g.append($path),\n    )\n  }\n})\n\n$svg.ontouchstart = $svg.ontouchmove = $svg.ontouchend = $svg.ontouchcancel = (ev) => {\n  ev.preventDefault()\n  ev.stopPropagation()\n}\n\nconst mid = (a: Vec, b: Vec): Vec => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 })\nconst M = ({ x, y }) => `M${x.toFixed(2)},${y.toFixed(2)}`;\nconst L = ({ x, y }) => `L${x.toFixed(2)},${y.toFixed(2)}`;\nconst Q = (c, { x, y }) => `Q${c.x.toFixed(2)},${c.y.toFixed(2)} ${x.toFixed(2)},${y.toFixed(2)}`;\n\nfunction render() {\n  if (!scheduled) return;\n  scheduled = false\n  let size = $settings.size.valueAsNumber\n  let t0 = performance.now()\n  for (let id in dirty) {\n    if (strokes[id]) {\n      let [stroke, $path] = strokes[id], d = ''\n      for (let index of stroke.sections) {\n        d += simple_bezier(stroke.outline(index, size))\n      }\n      $path.setAttribute('d', d)\n    }\n    delete dirty[id]\n  }\n  renderingMs = performance.now() - t0\n}\n\nfunction simple_bezier(points: Vec[]) {\n  if (points.length == 0) return '';\n  let prev = points.shift()!, d = M(prev), i = 1;\n  for (let curr of points) {\n    if (i) d += L(mid(prev, curr))\n    d += Q(prev, mid(prev, curr))\n    i = 0\n    prev = curr\n  }\n  return d + L(points[points.length - 1])\n}\n\nObject.assign(window, {\n  debug: { undoStack, strokes, dirty, input }\n})\n"],"names":["norm","x","y","d","add","a","b","sub","mul","n","per","neg","rot","C","r","s","c","px","py","nx","ny","dot","lerp","t","proj","Point","p","v","l","Stroke","points","length","from","raw","skip_sections","curr","prev_","prev","size","end","leftPoints","rightPoints","len","radius","prevPressure","drawEndCap","i","sp","rp","pressure","nextVector","nextDot","offset","pl","pr","startCap","endCap","step","lastPoint","direction","start","circle","sections","q","json","last_length","Observable","event","fn","set","args","f","error","Pinch","input","area","ev","desc","id","nav","browser","Input","paused","gesture","windowsScroll","ev2","id2","rect","ev0","left","top","ev1","_a","pred","deltaX","deltaY","scale","element","eventMap","name","val","min","max","real","config","$root","$svg","$g","$settings","renderingMs","total","updateData","stroke","bytes","prettyBytes","err","undoStack","undo","redo","current","scheduled","strokes","dirty","$path","render","commit","mid","M","L","Q","t0","index","simple_bezier"],"mappings":"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"}